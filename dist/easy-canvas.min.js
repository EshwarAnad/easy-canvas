(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.easyCanvas = factory());
}(this, (function () { 'use strict';

  const DISPLAY = {
    BLOCK: 'block',
    INLINE_BLOCK: 'inline-block',
    INLINE: 'inline', // 用户不能设置inline，text默认为inline
    FLEX: 'flex',
    NONE: 'none'
  };

  const WIDTH = {
    AUTO: 'auto',
    OUTER: '100%'
  };

  const POSITION = {
    ABSOLUTE: 'absolute',
    FIXED: 'fixed',
    RELATIVE: 'relative',
    STATIC: 'static'
  };

  const TEXT_ALIGN = {
    LEFT: 'left',
    RIGHT: 'right',
    CENTER: 'center'
  };

  const FLEX_DIRECTION = {
    ROW: 'row',
    COLUMN: 'column'
  };

  const DEFAULT_STYLES = {
    display: DISPLAY.BLOCK,
    fontSize: 14,
    fontWeight: 400,
    fontFamily: "Microsoft Yahei",
    color: '#000',
    paddingTop: 0,
    paddingBottom: 0,
    paddingLeft: 0,
    paddingRight: 0,
    marginTop: 0,
    marginBottom: 0,
    marginLeft: 0,
    marginRight: 0,
    height: WIDTH.AUTO,
    borderRadius: 0,
    lineCap: 'square',
    flexDirection: FLEX_DIRECTION.ROW,
    verticalAlign: 'middle',
    textAlign: 'left',
    justifyContent: 'flex-start',
    alignItems: 'flex-start',
    whiteSpace: 'normal',
    zIndex: 1,
    visible: true,
    position: 'static'
  };

  var STYLES = {
    DISPLAY,
    WIDTH,
    POSITION,
    DEFAULT_STYLES,
    TEXT_ALIGN,
    FLEX_DIRECTION
  };

  function isExact(num) {
    return typeof num === 'number'
  }

  function isAuto(num) {
    return num === 'auto'
  }

  function isOuter(num) {
    if (typeof num !== 'string') return
    return num.match('%')
  }

  function parseOuter(num) {
    let _n = parseInt(num.replace('%', ''));
    return (isNaN(_n) || _n < 0) ? 0 : (_n / 100)
  }


  function walk(element, callback) {
    let _continue = false; // 是否跳过当前节点以及后面的节点
    let _next = false; // 是否跳过当前节点数，子元素都不会遍历
    const _callContinue = () => _continue = true;
    const _callNext = () => _next = true;
    if (element != null) {
      var stack = [];
      stack.push(element);
      while (stack.length != 0) {
        var item = stack.pop();
        callback(item, _callContinue, _callNext);
        if (!_next) {
          var children = item._getChildren();
          for (var i = children.length - 1; i >= 0; i--) {
            if (!_continue) {
              stack.push(children[i]);
            } else {
              // 复位
              _continue = false;
            }

          }

        } else {
          // 复位
          _next = false;
        }
      }
    }
  }

  function walkParent(element, callback) {
    if (!element) return
    let cur = element;
    let stop = false;
    const callbreak = () => {
      stop = true;
    };
    while (cur.parent) {
      callback(cur.parent, callbreak);
      if (stop) {
        break
      }
      cur = cur.parent;
    }
  }

  function findRelativeTo(element) {
    if (element.isInFlow()) return element.parent
    if (element.renderStyles.position === 'fixed') return element.root
    let relativeTo = null;
    walkParent(element, (parent) => {
      if (parent.renderStyles.position !== 'static' && !relativeTo) {
        relativeTo = parent;
      }
    });
    if (!relativeTo) {
      relativeTo = element.root;
    }
    return relativeTo
  }


  function isWX() {
    return !window
  }

  function isEndNode(el) {
    return el.parent && !el.next && !el.hasChildren()
  }

  function breadthFirstSearch(node) {

    var nodes = [];

    if (node != null) {

      var queue = [];

      queue.unshift(node);

      while (queue.length != 0) {

        var item = queue.shift();

        nodes.push(item._generateRender());

        var children = item._getChildren();

        for (var i = 0; i < children.length; i++)
          queue.push(children[i]._generateRender());

      }

    }

    return nodes;

  }

  function breadthFirstSearchRight(node) {

    var nodes = [];

    if (node != null) {

      var queue = [];

      queue.unshift(node);

      while (queue.length != 0) {

        var item = queue.shift();

        nodes.push(item._generateRender());

        var children = item._getChildren();

        for (var i = children.length - 1; i >= 0; i--)
          queue.push(children[i]._generateRender());

      }

    }

    return nodes.reverse();

  }

  function needReflow(style) {
    return ['width',
      'height',
      'position',
      'display',
      'padding',
      'paddingTop',
      'paddingLeft',
      'paddingBottom',
      'paddingRight',
      'margin',
      'marginLeft',
      'marginTop',
      'marginBottom',
      'marginRight',
      'borderWidth',
      'flexDirection',
      'justifyContent',
      'alignItems',
      'textAlign',
      'left',
      'top',
      'right',
      'bottom'
    ].includes(style)
  }

  const mergeKeys = ['attrs', 'styles', 'on'];
  function mergeOptions(options, mergeOptions) {
    let mergedOptions = {};
    mergeKeys.forEach(key => {
      if (!options[key]) options[key] = {};
      if (!mergeOptions[key]) mergeOptions[key] = {};
      mergedOptions[key] = Object.assign({}, options[key], mergedOptions[key]);
    });
    return mergedOptions
  }


  function floor(val){
    return (0.5 + val) << 0
  }

  function getThrottle(threshold) {
      let timer;
      return function (fn) {
          if (!timer) {
              timer = setTimeout(function () {
                  fn();
                  timer = null;
              }, threshold);
          }
      }
  }

  class Line {
    constructor() {
      this.width = 0;
      this.height = 0;
      this.contentWidth = 0; // 右边界
      this.y = 0; // 上
      this.doorClosed = false; // 是否允许加入
      this.outerWidth = 0;
      this.container = null;
      this.elements = [];
      this.start = null; // 起点，行最左边第一个
      this.end = null; // 结束
      this.offsetX = 0;
      this.id = Math.random();
    }

    bind(el) {
      this.container = el.parent;
      this.initHeight(el);
      this.outerWidth = el.parent && isAuto(el.parent.styles.width) ? Infinity : el.parent.renderStyles.contentWidth;

      this.start = el;
      this.add(el);
    }

    initHeight(el) {
      this.height = el.parent && el.parent.renderStyles.lineHeight || 0;
    }

    initLayout(el) {
      this.right = el._getContainerLayout().contentX;
      this.x = el._getContainerLayout().contentX;
      this.y = this.getPreLine(el).y;
    }

    refreshElementPosition(el) {
      if (this.start === el) {
        this.initLayout(el);
      }
      // 刷新位置，首先以左边计算
      el.x = this.right + this.offsetX;
      el.y = this.y + this.getOffsetY(el);
      // + (this.height - el.renderStyles.height) / 2
      this.right += el.renderStyles.width;

    }

    getOffsetY(el) {
      if (el.renderStyles.verticalAlign === 'bottom') {
        return (this.height - el.renderStyles.height)
      } else if (el.renderStyles.verticalAlign === 'middle') {
        return (this.height - el.renderStyles.height) / 2
      } else {
        return 0
      }
    }


    add(el) {
      this.elements.push(el);
      el.line = this;
      this.refreshWidthHeight(el);

      if (!el.next || el.next.renderStyles.display !== 'inline-block') {
        this.closeLine();
      }
    }

    refreshWidthHeight(el) {
      if (el.renderStyles.height > this.height) {
        this.height = el.renderStyles.height;
      }

      this.width += el.renderStyles.width;
    }

    canIEnter(el) {
      if ((el.renderStyles.width + this.width) > this.outerWidth) {
        this.closeLine();
        return false
      } else {
        return true
      }
    }

    closeLine() {
      // new line
      this.end = this.elements[this.elements.length - 1];
      this.refreshXAlign();

    }

    getPreLine(el) {
      if (el.pre) {
        if (el.pre.line) {
          return { y: el.pre.line.height + el.pre.line.y, x: el.pre.line.x }
        } else {
          return { y: el._getPreLayout().y + el._getPreLayout().height, x: el._getPreLayout().x }
        }
      } else {
        return { y: el._getContainerLayout().contentY, x: el._getContainerLayout().contentX }
      }
    }

    refreshXAlign() {
      if (this.outerWidth > 5000) return
      if (!this.end.parent) return
      let offsetX = this.outerWidth - this.width;
      if (this.end.parent.renderStyles.textAlign === 'center') {
        offsetX = offsetX / 2;
      } else if (this.end.parent.renderStyles.textAlign === 'left') {
        offsetX = 0;
      }
      this.offsetX = offsetX;
    }
  }

  const KEY = {
    [STYLES.FLEX_DIRECTION.ROW]: {
      width: 'width',
      contentWidth: 'contentWidth',
      x: 'x',
      y: 'y',
      contentX: 'contentX',
      height: 'height',
      contentHeight: 'contentHeight'
    },
    [STYLES.FLEX_DIRECTION.COLUMN]: {
      width: 'height',
      contentWidth: 'contentHeight',
      x: 'y',
      y: 'x',
      contentX: 'contentY',
      height: 'width',
      contentHeight: 'contentWidth'
    }
  };
  // 目前flex是基于inline-block的简单实现，只支持row方向width + flex混用
  class FlexBox extends Line {
    constructor() {
      super();
      this.exactValue = 0;
      this.flexTotal = 0;
      this.key = null;
    }

    closeLine() {
      super.closeLine();
      this.calcFlex();
    }

    bind(el) {
      this.container = el.parent;
      if (el.parent) {
        this.key = KEY[el.parent.renderStyles.flexDirection];
      }
      this.initHeight(el);
      this.outerWidth = el.parent && isAuto(el.parent.styles[this.key.width]) ? Infinity : el.parent.renderStyles[this.key.contentWidth];
      this.start = el;
      this.add(el);
    }

    add(el) {
      if (isExact(el.styles.flex)) {
        this.flexTotal += el.styles.flex;
      } else if (isExact(el.styles[this.key.width])) {
        this.exactValue += el.styles[this.key.width];
      }

      this.elements.push(el);
      el.line = this;
      this.refreshWidthHeight(el);

      if (!el.next) {
        this.closeLine();
      }
    }

    initHeight() {
      this[this.key.height] = 0;
    }

    refreshWidthHeight(el) {
      if (el.renderStyles[this.key.height] > this[this.key.height]) {
        this[this.key.height] = el.renderStyles[this.key.height];
      }

      this[this.key.width] += el.renderStyles[this.key.width];
    }

    initLayout(el) {
      this.right = el._getContainerLayout()[this.key.contentX];
      this[this.key.x] = el._getContainerLayout()[this.key.contentX];
      this[this.key.y] = this.getPreLine(el)[this.key.y];
    }

    refreshElementPosition(el) {
      if (this.start === el) {
        this.initLayout(el);
      }
      // 刷新位置，首先以左边计算
      el[this.key.x] = this.right + this.offsetX;
      el[this.key.y] = this[this.key.y] + this.getOffsetY(el);
      // + (this.height - el.renderStyles.height) / 2
      this.right += el.renderStyles[this.key.width];

    }

    calcFlex() {
      const { [this.key.contentWidth]: containerWidth } = this.container.renderStyles;
      this.elements.forEach(child => {
        if (isExact(child.styles.flex)) {
          child.renderStyles[this.key.width] = (child.styles.flex / this.flexTotal) * (containerWidth - this.exactValue);
          child._refreshContentWithLayout();
        }
      });
    }

    refreshXAlign() {
      if (!this.end.parent) return
      let offsetX = this.outerWidth - this[this.key.width];
      if (this.end.parent.renderStyles.justifyContent === 'center') {
        offsetX = offsetX / 2;
      } else if (this.end.parent.renderStyles.justifyContent === 'flex-start') {
        offsetX = 0;
      }
      this.offsetX = offsetX;
    }

    getOffsetY(el) {
      if (el.renderStyles.alignSelf === 'flex-end') {
        return (this.container.renderStyles[this.key.contentHeight] - el.renderStyles[this.key.height])
      } else if (el.renderStyles.alignSelf === 'center') {
        return (this.container.renderStyles[this.key.contentHeight] - el.renderStyles[this.key.height]) / 2
      } else {
        return 0
      }
    }
  }

  class TreeNode {

    static connectChildren(el) {
      if (el.hasChildren()) {
        el._getChildren().map((child, index) => {
          // 设置parent
          child._setParent(el);
          // 设置了上一个兄弟节点
          child._setSibling(el._getChildren()[index - 1], el._getChildren()[index + 1]);
          TreeNode.connectChildren(child);
        });
      }
    }

    constructor(children) {
      this.children = children || [];
      this.parent = null;
      this.root = null;
      this.pre = null;
      this.next = null;
    }



    hasChildren() {
      return Array.isArray(this.children) && this.children.length ? true : false
    }

    _getChildren() {
      return this.hasChildren() ? this.children : []
    }

    _setParent(element) {
      this.parent = element;
      this.root = element.root;
    }

    _setSibling(pre, next) {
      this.pre = pre || null;
      this.next = next || null;
    }


    // 添加在最后
    appendChild(treeNode) {
      if (!treeNode instanceof TreeNode) throw Error('Unknown treeNode type')
      const pre = this._getChildren()[this._getChildren().length - 1];
      pre && pre._setSibling(pre.pre,treeNode);
      this.children.push(treeNode);
      treeNode._setParent(this);
      treeNode._setSibling(pre, null);
      // return treeNode
    }

    //
    prependChild(treeNode) {
      if (!treeNode instanceof TreeNode) throw Error('Unknown treeNode type')
      const next = this._getChildren()[0];
      next && next._setSibling(treeNode,next.next);
      this.children.unshift(treeNode);
      treeNode._setParent(this);
      treeNode._setSibling(null, next);
      // return treeNode
    }

    removeChild(treeNode) {
      if (!treeNode instanceof TreeNode) throw Error('Unknown treeNode type')
      const index = this._getChildren().indexOf(treeNode);
      if (index < 0) throw Error('treeNode must be the child of parent')
      const pre = this._getChildren()[index - 1];
      const next = this._getChildren()[index + 1];
      if (pre) {
        pre._setSibling(pre.pre, next);
      }
      if (next) {
        next._setSibling(pre, next.next);
      }
      this.children.splice(index, 1);
    }

    remove() {
      if (!this.parent) {
        throw Error('Can not remove root node')
      }
      this.parent.removeChild(this);
    }

    append(treeNode) {
      if (!treeNode instanceof TreeNode) throw Error('Unknown treeNode type')
      if (!this.parent) throw Error('Can not add treeNode to root level!')
      let children = [];
      treeNode._setParent(this.parent);
      this.parent.children.forEach((child, index) => {
        children.push(child);
        if (child === this) {
          treeNode._setSibling(child, this.parent.children[index + 1]);
          children.push(treeNode);
        }
      });
      this.parent.children = children;
    }

    prepend(treeNode) {
      if (!treeNode instanceof TreeNode) throw Error('Unknown treeNode type')
      if (!this.parent) throw Error('Can not add treeNode to root level!')
      let children = [];
      treeNode._setParent(this.parent);
      for (let i = this.parent.children.length - 1; i >= 0; i--) {
        children.unshift(this.parent.children[i]);
        if (this.parent.children[i] === this) {
          treeNode._setSibling(this.parent.children[i - 1], this.parent.children[i]);
          children.unshift(treeNode);
        }
      }
      this.parent.children = children;
    }


  }

  function completeStyles (element) {
    _completeFlex(element);

    _completeWidth(element);

    _completeBorder(element);

    _completeFont(element);

    _completePaddingMargin(element);
  }


  function _completePaddingMargin(element) {
    if (element.styles.padding) {
      if (isExact(element.styles.padding)) {
        element.styles.paddingLeft = element.styles.padding;
        element.styles.paddingBottom = element.styles.padding;
        element.styles.paddingRight = element.styles.padding;
        element.styles.paddingTop = element.styles.padding;
      } else if (Array.isArray(element.styles.padding)) {
        // 支持数组[10,20]相当于padding:10px 20px;
        if (element.styles.padding.length === 2) {
          element.styles.paddingLeft = element.styles.paddingRight = element.styles.padding[1];
          element.styles.paddingBottom = element.styles.paddingTop = element.styles.padding[0];
        } else if (element.styles.padding.length === 4) {
          element.styles.paddingLeft = element.styles.padding[3];
          element.styles.paddingBottom = element.styles.padding[2];
          element.styles.paddingRight = element.styles.padding[1];
          element.styles.paddingTop = element.styles.padding[0];
        }
      }
    }

    if (isExact(element.styles.margin)) {
      element.styles.marginLeft = element.styles.margin;
      element.styles.marginBottom = element.styles.margin;
      element.styles.marginRight = element.styles.margin;
      element.styles.marginTop = element.styles.margin;
    } else if (Array.isArray(element.styles.margin)) {
      // 支持数组[10,20]相当于padding:10px 20px;
      if (element.styles.margin.length === 2) {
        element.styles.marginLeft = element.styles.marginRight = element.styles.margin[1];
        element.styles.marginBottom = element.styles.marginTop = element.styles.margin[0];
      } else if (element.styles.margin.length === 4) {
        element.styles.marginLeft = element.styles.margin[3];
        element.styles.marginBottom = element.styles.margin[2];
        element.styles.marginRight = element.styles.margin[1];
        element.styles.marginTop = element.styles.margin[0];
      }
    }
  }

  /**
   * borderwidth到各个边
   */
  function _completeBorder(element) {
    let { borderWidth, borderLeftWidth, borderRightWidth, borderBottomWidth, borderTopWidth, borderRadius } = element.styles;
    if (!borderWidth) {
      element.styles.borderWidth = 0;
      borderWidth = 0;
    }
    if (Array.isArray(borderWidth)) {
      element.styles.borderTopWidth = borderWidth[0];
      element.styles.borderRightWidth = borderWidth[1];
      element.styles.borderBottomWidth = borderWidth[2];
      element.styles.borderLeftWidth = borderWidth[3];
    } else {
      if (!borderLeftWidth) {
        element.styles.borderLeftWidth = borderWidth;
      }
      if (!borderRightWidth) {
        element.styles.borderRightWidth = borderWidth;
      }
      if (!borderBottomWidth) {
        element.styles.borderBottomWidth = borderWidth;
      }
      if (!borderTopWidth) {
        element.styles.borderTopWidth = borderWidth;
      }
    }
    if (borderRadius) {
      element.styles.overflow = 'hidden';
    }
  }

  function _completeWidth(element) {
    if (!element.styles.width) {
      if (element.styles.display === STYLES.DISPLAY.INLINE_BLOCK || element.styles.display === STYLES.DISPLAY.INLINE || !element.isInFlow()) {
        element.styles.width = STYLES.WIDTH.AUTO;
      } else if (element.styles.display === STYLES.DISPLAY.BLOCK || element.styles.display === STYLES.DISPLAY.FLEX) {
        element.styles.width = STYLES.WIDTH.OUTER;
      } else {
        element.styles.width = 0;
      }
    }

    if (isOuter(element.styles.width)) {
      if (element.parent && isAuto(element.parent.styles.width)) {
        element.styles.width = STYLES.WIDTH.AUTO;
      }
    }

    if (isOuter(element.styles.height)) {
      if (element.parent && isAuto(element.parent.styles.height)) {
        element.styles.height = STYLES.WIDTH.AUTO;
      }
    }
  }

  function _completeFont(element) {
    if (element.styles.fontSize && !element.styles.lineHeight) {
      element.styles.lineHeight = element.styles.fontSize * 1.4;
    }
  }

  function _completeFlex(element) {
    if (element.parent && element.parent.styles.display === STYLES.DISPLAY.FLEX) {
      // flex布局内 width 和flex需要有一个
      if (!element.styles.flex) {
        if (!isExact(element.styles.height) && !isExact(element.styles.width)) {
          element.styles.flex = 1;
        }
      } else {
        if (element.parent.styles.flexDirection === 'column' && isExact(element.styles.flex)) {
          element.styles.height = 0;
        } else if (element.parent.styles.flexDirection === 'row' && isExact(element.styles.flex)) {
          element.styles.width = 0;
        }
      }

    }
  }

  /**
   * Element类实现盒模型以及定位，不具备绘制
   * 其他类继承实现
   *
   */




  class Element extends TreeNode {
    constructor(options, children) {
      super(children);
      this.options = Object.assign({ attrs: {}, styles: {}, on: {} }, options);
      this.styles = null;
      this.renderStyles = null;
      this.x = 0;
      this.y = 0;
      this.render = null;
      this.container = null;
      this.visible = true;
    }

    init() {
      this._initStyles();
      this.initEvent();
    }

    initEvent() {
      if (this.options.on) {
        Object.keys(this.options.on).forEach(eventName => {
          if(this.getLayer().eventManager.EVENTS.includes(eventName)){
            this.getLayer().eventManager.addEventListener(eventName,this.options.on[eventName], this);
          }
        });
      }
    }

    removeEvent() {
      this.getLayer().eventManager.removeElement(this);
    }

    getLayer() {
      return this.root.layer
    }

    getRender() {
      return this.root.layer.render
    }

    _paint() {

    }

    mount(layer) {
      layer.mountNode(this);
    }

    _initStyles() {
      this.styles = Object.assign({}, this._getDefaultStyles(), this._getParentStyles(this.options.styles), this.options.styles || {});

      this._completeStyles();

      this._initRenderStyles();
    }

    _initRenderStyles() {
      const renderStyles = { ...this.styles };
      const parentWidth = this._getContainerLayout().contentWidth;
      const parentHeight = this._getContainerLayout().contentHeight;

      if (isAuto(renderStyles.width)) {
        renderStyles.width = 0;
      } else if (isOuter(renderStyles.width)) {
        renderStyles.width = parseOuter(renderStyles.width) * parentWidth;
      }

      if (isAuto(renderStyles.height)) {
        renderStyles.height = 0;
      } else if (isOuter(renderStyles.height)) {
        renderStyles.height = parseOuter(renderStyles.height) * parentHeight;
      }

      if (!renderStyles.width) renderStyles.width = 0;
      if (!renderStyles.height) renderStyles.height = 0;

      renderStyles.width = floor(renderStyles.width);
      renderStyles.height = floor(renderStyles.height);

      // 初始化contentWidth
      renderStyles.contentWidth = renderStyles.width - renderStyles.paddingLeft - renderStyles.paddingRight - renderStyles.marginLeft - renderStyles.marginRight - this._getTotalBorderWidth(renderStyles);
      renderStyles.contentHeight = renderStyles.height - renderStyles.paddingTop - renderStyles.paddingBottom - renderStyles.marginTop - renderStyles.marginBottom - this._getTotalBorderHeight(renderStyles);

      this.renderStyles = renderStyles;

      if (this._InFlexBox()) {
        this._bindFlexBox();
      } else if (!this.isInFlow()) {
        this.relativeTo = findRelativeTo(this);
      }


    }

    /**
     * 需要继承的styles放在这里
     */
    _getParentStyles(curStyles) {
      let { textAlign, lineHeight, fontSize, color, fontFamily, alignItems, visible = true } = this.parent && this.parent.renderStyles || {};
      let extendStyles = {};
      if (textAlign) extendStyles.textAlign = textAlign;
      if (fontSize) extendStyles.fontSize = fontSize;
      if (color) extendStyles.color = color;
      if (fontFamily) extendStyles.fontFamily = fontFamily;
      if (alignItems && !curStyles.alignSelf) extendStyles.alignSelf = alignItems;
      extendStyles.visible = visible;
      return extendStyles
    }

    _completeStyles() {
      completeStyles(this);
    }

    _getDefaultStyles() {
      return STYLES.DEFAULT_STYLES
    }

    // 获取文档流中的子节点
    _getChildrenInFlow() {
      return this._getChildren().filter(item => item.isInFlow())
    }

    // 是否在文档流中
    isInFlow() {
      const { position, display } = this.styles;
      return position !== STYLES.POSITION.ABSOLUTE && position !== STYLES.POSITION.FIXED
    }

    isVisible() {
      return this.renderStyles.visible && this.visible
    }

    _generateRender() {
      return this
    }

    getCtx() {
      return this.root.layer.ctx
    }

    /**
     * 实现文档流 需要知道上一个兄弟节点
     */
    _reflow() {


    }

    _initWidthHeight() {
      const { width, height, display, flex, marginLeft, marginRight, marginTop, marginBottom } = this.styles;
      if (isAuto(width) || isAuto(height)) {
        // 这一步需要遍历，判断一下
        const layout = this._measureLayout();
        // 初始化宽度高度
        if (isAuto(width)) {
          this.renderStyles.contentWidth = floor(layout.width);
        }

        if (isAuto(height)) {
          // 不填就是auto
          this.renderStyles.contentHeight = floor(layout.height);
        }
      }

      this._refreshLayoutWithContent();

      if (this._InFlexBox()) {
        this.line.refreshWidthHeight(this);
      } else if (display === STYLES.DISPLAY.INLINE_BLOCK) {
        // 如果是inline-block  这里仅计算高度
        this._bindLine();
      }
    }

    _initPosition() {
      let { contentX } = this._getContainerLayout();
      const { paddingLeft, paddingTop, borderLeftWidth, borderTopWidth, marginLeft, marginTop } = this.renderStyles;
      // 初始化ctx位置
      if (!this.isInFlow()) {
        // 不在文档流中
        let { contentX, contentY, contentWidth, contentHeight } = this._getContainerLayout(this.relativeTo);
        let { top, bottom, right, left, width, height } = this.renderStyles;
        if (isOuter(top)) top = parseOuter(top) * contentHeight;
        if (isOuter(bottom)) bottom = parseOuter(bottom) * contentHeight;
        if (isOuter(left)) left = parseOuter(left) * contentWidth;
        if (isOuter(right)) right = parseOuter(right) * contentWidth;
        if (isExact(top)) {
          this.y = contentY + top;
        } else if (isExact(bottom)) {
          this.y = contentY + contentHeight - bottom - height;
        }

        if (isExact(left)) {
          this.x = contentX + left;
        } else if (isExact(right)) {
          this.x = contentX + contentWidth - right - width;
        }
      } else if (this._InFlexBox()) {
        this.line.refreshElementPosition(this);
      } else if (this.renderStyles.display === STYLES.DISPLAY.INLINE_BLOCK) {
        // inline-block到line里计算
        // this._bindLine()
        this.line.refreshElementPosition(this);
      } else {
        this.x = contentX;
        this.y = this._getPreLayout().y + this._getPreLayout().height;
      }
      this.x = floor(this.x);
      this.y = floor(this.y);
      this.contentX = this.x + paddingLeft + borderLeftWidth + marginLeft;
      this.contentY = this.y + paddingTop + borderTopWidth + marginTop;
    }

    _InFlexBox() {
      if (!this.isInFlow()) return false
      if (!this.parent) return false
      if (this.parent && this.parent.renderStyles.display === STYLES.DISPLAY.FLEX) return true
    }


    // 父元素根据子元素撑开content后，再计算width
    _refreshLayoutWithContent() {
      this.renderStyles.height = floor(this.renderStyles.contentHeight + this.renderStyles.paddingTop + this.renderStyles.paddingBottom + this.renderStyles.marginTop + this.renderStyles.marginBottom + this._getTotalBorderHeight());
      this.renderStyles.width = floor(this.renderStyles.contentWidth + this.renderStyles.paddingLeft + this.renderStyles.paddingRight + this.renderStyles.marginLeft + this.renderStyles.marginRight + this._getTotalBorderWidth());
    }

    // 父元素根据子元素撑开content后，再计算width
    _refreshContentWithLayout() {
      this.renderStyles.contentHeight = this.renderStyles.height - this.renderStyles.paddingTop - this.renderStyles.paddingBottom - this.renderStyles.marginTop - this.renderStyles.marginBottom - this._getTotalBorderHeight();
      this.renderStyles.contentWidth = this.renderStyles.width - this.renderStyles.paddingLeft - this.renderStyles.paddingRight - this.renderStyles.marginLeft - this.renderStyles.marginRight - this._getTotalBorderWidth();
    }

    _getTotalBorderWidth(renderStyles = this.renderStyles) {
      return renderStyles.borderLeftWidth + renderStyles.borderRightWidth
    }

    _getTotalBorderHeight(renderStyles = this.renderStyles) {
      return renderStyles.borderTopWidth + renderStyles.borderBottomWidth
    }

    _bindLine() {
      if (this.pre && this.pre.line && this.pre.line.canIEnter(this)) {
        this.pre.line.add(this);
      } else {
        // 新行
        new Line().bind(this);
      }
    }

    _bindFlexBox() {
      if (this.pre && this.pre.line) {
        this.pre.line.add(this);
      } else {
        // 新行
        new FlexBox().bind(this);
      }
    }

    _getContainerLayout(container = this.parent) {
      if (!container) {
        // root
        if (!this.container) {
          debugger
        }
        container = {
          renderStyles: {
            width: this.container.width,
            height: this.container.height,
            paddingTop: 0,
            paddingBottom: 0,
            paddingLeft: 0,
            paddingRight: 0,
            marginLeft: 0,
            marginRight: 0,
            marginTop: 0,
            marginBottom: 0,
            contentWidth: this.container.width,
            contentHeight: this.container.height
          },
          x: 0,
          y: 0,
          contentX: 0,
          contentY: 0
        };
      }
      return {
        width: container.renderStyles.width,
        height: container.renderStyles.height,
        x: container.x,
        y: container.y,
        paddingTop: container.renderStyles.paddingTop,
        paddingBottom: container.renderStyles.paddingBottom,
        paddingLeft: container.renderStyles.paddingLeft,
        paddingRight: container.renderStyles.paddingRight,
        marginLeft: container.renderStyles.marginLeft,
        marginRight: container.renderStyles.marginRight,
        marginTop: container.renderStyles.marginTop,
        marginBottom: container.renderStyles.marginBottom,
        contentX: container.contentX,
        contentY: container.contentY,
        contentWidth: container.renderStyles.contentWidth,
        contentHeight: container.renderStyles.contentHeight
      }
    }

    // 这里前一个节点必须在文档流中
    _getPreLayout() {
      let cur = this.pre;
      while (cur && !cur.isInFlow()) {
        cur = cur.pre;
      }
      // 如果没有前一个或者前面的都不在文档流中，获取容器的
      if (cur) {
        return {
          width: cur.renderStyles.width,
          height: cur.renderStyles.height,
          x: cur.x,
          y: cur.y
        }
      } else {
        return {
          width: 0,
          height: 0,
          x: this._getContainerLayout().contentX,
          y: this._getContainerLayout().contentY
        }
      }
    }

    // 计算自身的高度
    _measureLayout() {
      let width = 0; // 需要考虑原本的宽度
      let height = 0;
      this._getChildrenInFlow().forEach(child => {
        if (child.line) {
          if (child.line.start === child) {
            if (child.line.width > width) {
              width = child.line.width;
            }
            height += child.line.height;
          }
        } else if (child.renderStyles.width > width) {
          width = child.renderStyles.width;
          height += child.renderStyles.height;
        } else {
          height += child.renderStyles.height;
        }
      });

      return { width, height }
    }

    // 获取元素，只会找该元素子级
    getElementBy(key, value) {
      let match = [];
      walk(this, (element) => {
        if (element.options.attrs[key] === value) {
          match.push(element);
        }
      });
      return match
    }

    // 添加在最后
    appendChild(element) {
      super.appendChild(element);
      this.getLayer().onElementAdd(element);
      return element
    }

    //
    prependChild(element) {
      super.prependChild(element);
      this.getLayer().onElementAdd(element);
      return element
    }

    removeChild(element) {
      super.removeChild(element);
      this.getLayer().onElementRemove(element);
    }

    append(element) {
      super.append(element);
      this.getLayer().onElementAdd(element);
    }

    prepend(element) {
      super.prepend(element);
      this.getLayer().onElementAdd(element);
    }

    setStyles(styles) {
      let _needReflow = false;
      Object.keys(styles).forEach(key => {
        if (needReflow(key)) {
          _needReflow = true;
        } else {
          this.renderStyles[key] = styles[key];
        }
      });
      if (_needReflow) {
        Object.keys(styles).forEach(key => {
          this.options.styles[key] = styles[key];
        });
        this.getLayer().reflowElement(this,this);
        // console.warn('实验性功能')
      } else {
        this.getRender().requestRepaint();
      }
    }

  }

  class View extends Element {

    constructor(options, children) {
      super(options, children);
      this.type = 'view';
    }

    _getDefaultStyles() {
      return {
        ...STYLES.DEFAULT_STYLES,
        display: STYLES.DISPLAY.BLOCK
      }
    }

    _paint() {
      this.getRender()._drawBackground(this);
      this.getRender()._drawBox(this);
    }


  }

  class Text extends Element {
    constructor(options, children) {
      super(options, children);
      this._layout = null; // layout用来保存计算的自身高度
      this._lines = [];
      this.children += '';
      this.type = 'text';
    }

    _paint() {
      this.getRender()._drawBackground(this);
      this.getRender()._drawText(this);
      this.getRender()._drawBox(this);
    }

    _getDefaultStyles() {
      return {
        ...STYLES.DEFAULT_STYLES,
        display: STYLES.DISPLAY.INLINE_BLOCK,
        width: STYLES.WIDTH.AUTO,
        textAlign: 'left',
      }
    }

    _measureLayout() {
      this._layout = this.getRender().measureText(this, this.children);
      this._layout.fontHeight = this.renderStyles.fontSize * 0.8;
      this._layout.height = this.renderStyles.lineHeight;
      this._calcLine();
      return this._layout
    }

    _getFont() {
      const { fontSize, fontWeight, fontFamily } = this.renderStyles;
      return `${fontWeight} ${fontSize}px ${fontFamily}`
    }

    _calcLine() {
      if (!this.parent || !this.children) return
      const { width: textWidth, height: textHeight } = this._layout;
      let { contentWidth: parentContentWidth } = this.parent.renderStyles;
      const { width: parentWidth } = this.parent.styles;
      if (!isAuto(this.styles.width)) parentContentWidth = this.renderStyles.width;
      // 如果一行宽度够，或者父级宽度是auto
      if ((isExact(parentContentWidth) && parentContentWidth >= textWidth) || parentWidth === STYLES.WIDTH.AUTO) {
        this._lines = [this.children];
      } else {
        this._lines = [];
        let lineIndex = 1;
        let lineText = '';
        let _layout = null;
        for (let i = 0; i < this.children.length; i++) {
          _layout = this.getRender().measureText(this, lineText + this.children[i]);
          if (_layout.width > parentContentWidth) {
            if (lineIndex >= this.renderStyles.maxLine) {
              // 最大行数限制 以及maxline省略号实现
              lineText = lineText.substring(0, lineText.length - 2) + '...';
              break
            }
            // 超出了
            this._lines.push(lineText);
            lineText = '';
            lineIndex += 1;

          }

          lineText += this.children[i];
        }
        this._layout.width = parentContentWidth;
        this._lines.push(lineText);
        // 根据lineheihgt更新height
        this._layout.height = this._lines.length * this.renderStyles.lineHeight;
      }
    }

    getInnerText(){
      return this.children
    }

    setInnerText(val){
      if(val === undefined) return
      if(val === this.children) return
      this.children = val;
      this.getLayer().reflowElement(this);
    }
  }

  class $Image extends View {

    constructor(options, children) {
      super(options, children);
      this.type = 'image';
      this._imageInfo = {
        width: 0,
        height: 0,
        sx: 0,
        sy: 0,
        swidth: 0,
        sheight: 0,
        dx: 0,
        dy: 0,
        dwidth: 0,
        dheight: 0
      };
      this.debugColor = 'blue';
      this._image = null;
      this._layout = null;
    }

    init() {
      super.init();
      this._loadImage();
    }

    _paint() {
      this.getRender()._drawBackground(this);
      this.getRender()._drawImage(this);
      this.getRender()._drawBox(this);
    }

    _loadImage() {
      const { mode } = this.options.attrs;

      return new Promise((resolve, reject) => {
        this.getRender().getImageInstance(this.options.attrs.src)
          .then(({ info, image }) => {
            this._imageInfo = info;
            this._image = image;
            resolve();

            this._layoutImage();

            if (this.isVisible()) {
              // if (mode === 'aspectFill' || mode === 'aspectFit') {
              //   // this.getLayer().onElementChange(this)
              //   this.getLayer().repaint(this)
              // } else {
              // // 重新布局绘制
              this.getLayer().onElementChange(this.parent || this);
              // }
            }

            // call load callback
            if (this.options.on && this.options.on.load) {
              this.options.on.load(this);
            }
          })
          .catch(err => {
            // call error callback
            if (this.options.on && this.options.on.error) {
              this.options.on.error(err);
            }
          });
      })
    }

    // 计算图片布局
    _layoutImage() {
      const { contentWidth, contentHeight } = this.renderStyles;
      const { mode } = this.options.attrs;
      const { width, height } = this.styles;
      const { width: imageW, height: imageH } = this._imageInfo;
      // 根据用户设置判断图片宽高，目前支持widthfix、heightfix、平铺
      let w = contentWidth;
      let h = contentHeight;
      if (!isAuto(width) && isAuto(height)) {
        // width fix
        w = contentWidth;
        h = getHeightByWidth(w, imageW, imageH);
      } else if (!isAuto(height) && isAuto(width)) {
        // height fix
        h = contentHeight;
        w = getWidthByHeight(h, imageW, imageH);
      } else if (isAuto(width) && isAuto(height)) {
        // auto
        w = imageW;
        h = imageH;
      } else if (mode === 'aspectFill') {
        // 填充
        if ((w / h) > (imageW / imageH)) {
          this._imageInfo.swidth = imageW;
          this._imageInfo.sheight = getHeightByWidth(imageW, w, h);
          this._imageInfo.sx = 0;
          this._imageInfo.sy = (imageH - this._imageInfo.sheight) / 2;
        } else {
          this._imageInfo.sheight = imageH;
          this._imageInfo.swidth = getWidthByHeight(imageH, contentWidth, contentHeight);
          this._imageInfo.sy = 0;
          this._imageInfo.sx = (imageW - this._imageInfo.swidth) / 2;
        }
      } else if (mode === 'aspectFit') {
        if ((w / h) > (imageW / imageH)) {
          this._imageInfo.dwidth = getWidthByHeight(contentHeight, imageW, imageH);
          this._imageInfo.dheight = contentHeight;
          this._imageInfo.dy = this.contentY;
          this._imageInfo.dx = (contentWidth - this._imageInfo.dwidth) / 2 + this.contentX;
        } else {
          this._imageInfo.dheight = getHeightByWidth(contentWidth, imageW, imageH);
          this._imageInfo.dwidth = contentWidth;
          this._imageInfo.dx = this.contentX;
          this._imageInfo.dy = (contentHeight - this._imageInfo.dheight) / 2 + this.contentY;
        }
      } else {
        w = contentWidth;
        h = contentHeight;
      }
      this._layout = { width: w, height: h };
    }

    _measureLayout() {
      if (this._layout) {
        return this._layout
      } else {
        return {
          width: this.renderStyles.width,
          height: this.renderStyles.height
        }
      }
    }

  }


  function getWidthByHeight(height, originWidth, originHeight) {
    return height / originHeight * originWidth
  }

  function getHeightByWidth(width, originWidth, originHeight) {
    return width / originWidth * originHeight
  }

  const events = ['click','touchstart','touchmove','touchend','mousewheel'];
  class EventManager {

    constructor({ simulateClick = true }) {
      this.EVENTS = events;
      this.clear();
      this.touchStartEvent = null;
      this.simulateClick = simulateClick; // 是否模拟移动端点击事件
    }

    clear() {
      events.forEach(eventName => {
        this[`${eventName}Tree`] = new TreeNode();
        this[`${eventName}List`] = [];
      });
    }

    click(x, y) {
      let event = new Event({ x, y, type: 'click' });
      this._emit(event);
    }

    touchstart(x, y) {
      let event = new Event({ x, y, type: 'touchstart' });
      this.touchStartEvent = event;
      this._emit(event);
    }

    touchmove(x, y) {
      let event = new Event({ x, y, type: 'touchmove' });
      this._emit(event);
    }

    touchend(x, y) {
      let event = new Event({ x, y, type: 'touchend' });
      this._emit(event);
      this.checkClick(event);
    }

    mousewheel(x,y,deltaX,deltaY){
      let event = new Event({ x, y,deltaX,deltaY, type: 'mousewheel' });
      this._emit(event);
    }

    _emit(e) {
      let tree = this[`${e.type}Tree`];
      if(!tree) return

      /**
       * 遍历树，检查是否回调
       * 如果父级没有被触发，则子级也不需要检查，跳到下个同级节点
       * 执行capture回调，将on回调添加到stack
       */
      let callbackList = [];
      let curArr = tree._getChildren();
      while (curArr.length) {
        walkArray(curArr, (node, callBreak, isEnd) => {
          if (node.element.isVisible() && this.isPointInElement(e.relativeX, e.relativeY, node.element)) {
            node.runCapture(e);
            callbackList.unshift(node);
            // 同级后面节点不需要执行了
            callBreak();
            curArr = node._getChildren();
          } else if (isEnd) {
            // 到最后一个还是没监测到，结束
            curArr = [];
          }
        });
      }

      /**
       * 执行on回调，从子到父
       */
      for (let i = 0; i < callbackList.length; i++) {
        if (!e.currentTarget) e.currentTarget = callbackList[i].element;
        callbackList[i].runCallback(e);
        if (e.cancelBubble) break
      }
    }

    // 待优化
    isPointInElement(x, y, element) {
      let a1 = x >= element.x;
      let a2 = y >= element.y;
      let a3 = (x <= (element.x + element.renderStyles.width));
      let a4 = (y <= (element.y + element.renderStyles.height));
      if (a1 && a2 && a3 && a4) {
        return true
      }
      return false
    }


    removeElement(element) {
      events.forEach(eventName => {
        this[`${eventName}List`] = this[`${eventName}List`].filter(item => {
          if (item.element === element) {
            item.remove();
          }
          return item.element !== element
        });
      });
    }

    addEventListener(type,callback,element,isCapture){
      const tree = this[`${type}Tree`];
      const list = this[`${type}List`];
      if(!tree){
        console.error('Unknown event name [' + type+']');
      }
      this.addCallback(callback,element,tree,list,isCapture);
    }

    /**
     * 不在文档流中，提到relativeTo同级
     * 根据element树的层级关系构建一个监听回调树模型，提高性能
     * 有新的监听时，查找应该挂载在哪个节点
     * 如果节点已经存在，复用原节点
     * @param {Function} callback
     * @param {Element} element
     * @param {Callback} tree
     * @param {Array<Callback>} list
     * @param {Boolean} isCapture
     */
    addCallback(callback, element, tree, list, isCapture) {
      let parent = null;
      let node = null;
      // 寻找应该挂载的父节点
      let target = element;
      for (let i = list.length - 1; i >= 0; i--) {
        // 寻找已存在节点
        if (element === list[i].element) {
          // 当前
          parent = list[i - 1];
          node = list[i];
          break
        }
        // 寻找应该挂载的父节点 通过对比当前父级最近的父级
        if (!element.isInFlow()) {
          target = element.relativeTo.parent;
          if (!target) {
            break
          }
        }
        walkParent(target, (p, callBreak) => {
          if (p === list[i].element) {
            parent = list[i];
            callBreak();
          }
        });
        if (parent) {
          break
        }
      }

      // 如果不存在同样的元素节点
      if (!node) {
        node = new Callback(element, callback);
      }

      // 添加回调方法
      if (isCapture) {
        node.addCapture(callback);
      } else {
        node.addCallback(callback);
      }

      // 挂载节点
      if (parent) {
        // 用prepend是因为后来的层级上高于前面的，但是只有在absolute的元素才能感受到
        parent.prependChild(node);
      } else {
        tree.prependChild(node);
      }

      // 缓存到list
      list.push(node);
    }

    // 这里利用touchstart和touchend实现了移动端click事件
    checkClick(event) {
      if (this.touchStartEvent && this.simulateClick) {
        // 判断两点距离
        let { x: startx, y: starty } = this.touchStartEvent;
        let { x: endx, y: endy } = event;
        let distance = ((endy * endy + endx * endx) - (starty * starty + startx * startx));
        if (distance < 5 && distance > -5) {
          this.click(endx, endy);
        }
      }
    }
  }

  class Event {
    constructor({ x, y, type,deltaX,deltaY }) {
      this.x = x;
      this.y = y;
      this.relativeX = x; // scroll到每一层scrollview会不断变化
      this.relativeY = y;
      this.type = type;
      this.cancelBubble = false;
      this.currentTarget = null; // 第一个element

      if(type === 'mousewheel'){
        this.deltaX = deltaX;
        this.deltaY = deltaY;
      }
    }

    // 阻止冒泡
    stopPropagation() {
      this.cancelBubble = true;
    }
  }

  class Callback extends TreeNode {
    constructor(element) {
      super();
      this.element = element;
      this.callbackList = [];
      this.captureList = [];
    }

    addCallback(callback) {
      this.callbackList.push(callback);
    }

    addCapture(callback) {
      this.captureList.push(callback);
    }

    runCallback(params) {
      this.callbackList.forEach(item => item.call(this.element,params));
    }

    runCapture(params) {
      this.captureList.forEach(item => item.call(this.element,params));
    }

  }


  function walkArray(arr, callback) {
    let _break = false;
    const callBreak = () => _break = true;
    for (let i = 0; i < arr.length; i++) {
      callback(arr[i], callBreak, i === arr.length - 1 ? true : false);
      if (_break) {
        break
      }
    }
  }

  const angle = Math.PI / 2;

  /**
   * 封装图形api
   */
  class CanvasRender {
    constructor(layer) {
      this.layer = layer;
      this.imageBus = {};
      this.isAnimate = false;
      this.lastPaintTime = 0;
      this.lastFrameComplete = false;
      this.throttle = getThrottle(16);
    }

    getCtx() {
      return this.layer.ctx
    }

    getLayer() {
      return this.layer
    }

    _restore(callback) {
      this.getCtx().save();
      callback();
      this.getCtx().restore();
    }

    _path(callback) {
      this.getCtx().beginPath();
      callback();
      this.getCtx().closePath();
    }

    paint(element) {
      this.getCtx().save();

      element._paint(this.lastPaintTime);

      this.afterPaint(element);
    }

    afterPaint(element) {
      // 这里通过this.ctx栈实现了overflow
      // 第一步判断没有子元素，绘制完成即restore 有子元素需要子元素全部绘制完毕再restore
      if (!element.hasChildren() || element.type === 'text') {
        this.getCtx().restore();
      }

      // 如果到了层级的最后一个 释放父级的stack
      this._helpParentRestoreCtx(element);
    }

    _helpParentRestoreCtx(element) {
      if ((element.isVisible() && !isEndNode(element)) || (!element.isVisible() && element.next)) return
      this.getCtx().restore();
      let cur = element.parent;
      while (cur && !cur.next) {
        // 如果父级也是同级最后一个，再闭合上一个
        this.getCtx().restore();
        cur = cur.parent;
      }


    }

    topBorder({ x, y, borderRadius, w, h }) {
      // 左上角开始
      this.getCtx().moveTo(x, y + borderRadius);
      borderRadius && this.getCtx().arc(x + borderRadius, y + borderRadius, borderRadius, 2 * angle, 3 * angle);
      this.getCtx().lineTo(x + w - borderRadius, y);
    }

    rightBorder({ x, y, borderRadius, w, h }) {
      // 右上角
      // this.getCtx().moveTo(x + w - borderRadius, y)
      borderRadius && this.getCtx().arc(x + w - borderRadius, y + borderRadius, borderRadius, 3 * angle, 4 * angle);
      this.getCtx().lineTo(x + w, y + h - borderRadius);
    }

    bottomBorder({ x, y, borderRadius, w, h }) {
      // 右下角
      // this.getCtx().moveTo(x + w, y + h - borderRadius)
      borderRadius && this.getCtx().arc(x + w - borderRadius, y + h - borderRadius, borderRadius, 0, angle);
      this.getCtx().lineTo(x + borderRadius, y + h);
    }

    leftBorder({ x, y, borderRadius, w, h }) {
      // 左下角
      borderRadius && this.getCtx().arc(x + borderRadius, y + h - borderRadius, borderRadius, angle, angle * 2);
      this.getCtx().lineTo(x, y + borderRadius);
    }

    _drawBox(element) {
      if (!(element.renderStyles.borderColor || element.renderStyles.shadowBlur)) return
      const { contentWidth, contentHeight, paddingLeft, paddingTop, borderStyle,
        paddingRight, paddingBottom, shadowBlur, shadowColor, backgroundColor, shadowOffsetX, shadowOffsetY,
        borderLeftWidth, borderRightWidth, borderTopWidth, borderBottomWidth,borderWidth } = element.renderStyles;

      let borderRadius = getBorderRadius(element);


      // 这里是计算画border的位置，起点位置是在线条中间，所以要考虑线条宽度
      let x = element.contentX - element.renderStyles.paddingLeft - borderLeftWidth / 2;
      let y = element.contentY - element.renderStyles.paddingTop - borderTopWidth / 2;
      let w = contentWidth + paddingLeft + paddingRight + (borderLeftWidth + borderRightWidth) / 2;
      let h = contentHeight + paddingTop + paddingBottom + (borderTopWidth + borderBottomWidth) / 2;

      this.getCtx().lineCap = element.renderStyles.lineCap;
      this.getCtx().strokeStyle = element.renderStyles.borderColor;
      this.getCtx().lineJoin = 'round';

      // 实现虚线
      if (borderStyle && borderStyle !== 'solid') {
        if (Array.isArray(borderStyle)) {
          this.getCtx().setLineDash(borderStyle);
        } else {
          this.getCtx().setLineDash([5, 5]);
        }
      }

      const stroke = (borderWidth) => {
        // 有样式则绘制出来
        this.getCtx().lineWidth = borderWidth;
        this.getCtx().stroke();
      };
      this._restore(() => {
        this._path(() => {

          if (element.renderStyles.borderTopWidth) {
            this.topBorder({ x, y, borderRadius:borderRadius?borderRadius + (element.renderStyles.borderTopWidth/2):0, w, h });
            // 判断borderwidth 如果都是一样宽，只需要最后一次性绘制，提高性能
            !borderWidth && stroke(element.renderStyles.borderTopWidth);
          }
          if (element.renderStyles.borderRightWidth) {
            this.getCtx().moveTo(x + w - borderRadius- (element.renderStyles.borderTopWidth/2), y);
            this.rightBorder({ x, y,  borderRadius:borderRadius?borderRadius + element.renderStyles.borderRightWidth/2:0, w, h });
            !borderWidth && stroke(element.renderStyles.borderRightWidth);
          }
          if (element.renderStyles.borderBottomWidth) {
            this.getCtx().moveTo(x + w, y + h - borderRadius- (element.renderStyles.borderRightWidth/2));
            this.bottomBorder({ x, y,  borderRadius:borderRadius?borderRadius + (element.renderStyles.borderBottomWidth/2):0, w, h });
            !borderWidth && stroke(element.renderStyles.borderBottomWidth);
          }
          if (element.renderStyles.borderLeftWidth) {
            this.getCtx().moveTo(x + borderRadius+ element.renderStyles.borderBottomWidth/2, y + h);
            this.leftBorder({ x, y,  borderRadius:borderRadius?borderRadius + (element.renderStyles.borderLeftWidth/2):0, w, h });
            stroke(element.renderStyles.borderLeftWidth);
          }
        });
      });

    }

    _drawBackground(element) {
      const { backgroundColor, contentWidth, contentHeight, shadowColor, shadowBlur,
        paddingLeft, paddingRight, paddingTop, paddingBottom, opacity, shadowOffsetX, shadowOffsetY,
        borderLeftWidth, borderRightWidth, borderTopWidth, borderBottomWidth } = element.renderStyles;
      const ctx = this.getCtx();

      let borderRadius = getBorderRadius(element);


      // 这里是计算画border的位置，起点位置是在线条中间，所以要考虑线条宽度
      let x = element.contentX - element.renderStyles.paddingLeft - borderLeftWidth;
      let y = element.contentY - element.renderStyles.paddingTop - borderTopWidth;
      let w = contentWidth + paddingLeft + paddingRight + (borderLeftWidth + borderRightWidth);
      let h = contentHeight + paddingTop + paddingBottom + (borderTopWidth + borderBottomWidth);

      if (isExact(opacity)) {
        // 绘制透明图
        ctx.globalAlpha = opacity;
      }

      // 绘制boxshadow
      // 需要在clip之前
      if (shadowColor && shadowBlur) {
        this._restore(() => {
          this._path(() => {
            this.topBorder({ x, y, borderRadius, w, h });
            this.rightBorder({ x, y, borderRadius, w, h });
            this.bottomBorder({ x, y, borderRadius, w, h });
            this.leftBorder({ x, y, borderRadius, w, h });
          });
          if (isExact(shadowOffsetX)) {
            this.getCtx().shadowOffsetX = shadowOffsetX;
          }
          if (isExact(shadowOffsetY)) {
            this.getCtx().shadowOffsetY = shadowOffsetY;
          }
          this.getCtx().shadowBlur = shadowBlur;
          this.getCtx().shadowColor = shadowColor;
          this.getCtx().fillStyle = shadowColor;
          this.getCtx().fill();
        });
      }

      this._clip(element);



      // draw background
      if (backgroundColor) {
        this.getCtx().fillStyle = this._parseBackground(backgroundColor, element);
        this.getCtx().fillRect(element.contentX - paddingLeft, element.contentY - paddingTop, contentWidth + paddingLeft + paddingRight, contentHeight + paddingTop + paddingBottom);
      }

      // for debug
      if (this.getLayer().options && this.getLayer().options.debug) {
        this.getCtx().strokeStyle = 'green';
        this.getCtx().strokeRect(element.contentX, element.contentY, element.renderStyles.contentWidth, element.renderStyles.contentHeight);
        // ctx.strokeStyle = '#fff'
        // ctx.strokeText(`${parseInt(this.contentX)} ${parseInt(this.contentY)} ${contentWidth} ${contentHeight}`, this.contentX + 100, this.contentY + 10)

        //
      }
    }

    _clip(element) {
      if (element.renderStyles.overflow !== 'hidden') return
      const { contentWidth, contentHeight, paddingLeft, paddingTop,
        paddingRight, paddingBottom, shadowBlur, shadowColor, backgroundColor,
        borderLeftWidth, borderRightWidth, borderTopWidth, borderBottomWidth } = element.renderStyles;

      let borderRadius = getBorderRadius(element);

      // 为了把border也切进去
      let x = element.contentX - element.renderStyles.paddingLeft - borderLeftWidth;
      let y = element.contentY - element.renderStyles.paddingTop - borderTopWidth;
      let w = contentWidth + paddingLeft + paddingRight + borderLeftWidth + borderRightWidth;
      let h = contentHeight + paddingTop + paddingBottom + borderTopWidth + borderBottomWidth;

      this._path(() => {
        this.topBorder({ x, y, borderRadius, w, h });
        this.rightBorder({ x, y, borderRadius, w, h });
        this.bottomBorder({ x, y, borderRadius, w, h });
        this.leftBorder({ x, y, borderRadius, w, h });
      });


      this.getCtx().clip();

    }

    _parseBackground(color, element) {
      if (Array.isArray(color)) {
        const gradient = this.getCtx().createLinearGradient(element.contentX, element.contentY, element.renderStyles.contentWidth, element.renderStyles.contentHeight);
        for (let i = 0; i < color.length; i++) {
          if (i === 0) {
            gradient.addColorStop(0, color[0]);
          } else {
            gradient.addColorStop(i / (color.length - 1), color[i]);
          }
        }
        return gradient
      } else {
        return color
      }
    }


    _drawText(element) {
      const { color, contentWidth, lineHeight, textAlign, textIndent } = element.renderStyles;
      let x = element.contentX;
      this.getCtx().fillStyle = color;
      this.getCtx().textAlign = textAlign;
      this.getCtx().font = element._getFont();
      if (textAlign === STYLES.TEXT_ALIGN.RIGHT) {
        x = element.contentX + contentWidth;
      } else if (textAlign === STYLES.TEXT_ALIGN.CENTER) {
        x = element.contentX + (contentWidth / 2);
      }
      let _x = x;
      element._lines.forEach((line, index) => {
        if (index === 0 && textIndent) {
          // 第一行实现textIndent
          _x = x + textIndent;
        } else {
          _x = x;
        }
        this.getCtx().fillText(line, _x, (element.contentY + ((lineHeight + element._layout.fontHeight) / 2) + lineHeight * index));
      });
    }

    /**
     * @param {String} text
     * @return {Object<width,height>}
     */
    measureText(element, text) {
      let w = 0;
      this._restore(() => {
        this.getCtx().font = element._getFont();
        const { width } = this.getCtx().measureText(text);
        w = width;
      });
      return {
        width: w
      }
    }

    _drawImage(element) {
      if (!element._image) return
      const { contentWidth, contentHeight } = element.renderStyles;
      const { mode } = element.options.attrs;
      const { sx, sy, swidth, sheight, dx, dy, dwidth, dheight, width: imageW, height: imageH } = element._imageInfo;
      if (mode === 'aspectFill') {
        this.getCtx().drawImage(element._image, sx, sy, swidth, sheight, element.contentX, element.contentY, contentWidth, contentHeight);
      } else if (mode === 'aspectFit') {
        this.getCtx().drawImage(element._image, 0, 0, imageW, imageH, dx, dy, dwidth, dheight);
      } else {
        this.getCtx().drawImage(element._image, element.contentX, element.contentY, contentWidth, contentHeight);
      }
    }

    _drawScroll(element) {
      this.getCtx().translate(element.currentScrollX, element.currentScrollY);
    }

    /**
     * 这里应该保证onload src等接口
     */
    getImageInstance(src) {
      let image = null;

      // 同样的路径返回缓存
      if (this.imageBus[src]) {
        image = this.imageBus[src];
      } else {

        if (isWX()) {
          // 微信环境下必须传canvas
          if (!this.getCanvas()) {
            throw Error('微信小程序中需要在options中设置canvas以创建图片')
          }
          image = this.getCanvas().createImage();
        } else {
          image = new Image();
        }

        if (src) {
          this.imageBus[src] = new Promise((resolve, reject) => {
            image.onload = function (e) {
              resolve({
                image,
                info: {
                  width: e.target.width,
                  height: e.target.height
                }
              });
            };
          });
        }

        image.src = src;
      }
      return this.imageBus[src]
    }

    render(node) {
      this.lastFrameComplete = false;
      this.lastPaintTime = Date.now();
      if (!node.parent) {
        // root
        this.getCtx().clearRect(0, 0, this.getLayer().options.width, this.getLayer().options.height);
      } else {
        this.getCtx().clearRect(node.x, node.y, node.renderStyles.width, node.renderStyles.height);
      }
      walk(node, (renderNode, callContinue, callNext) => {
        if (renderNode.isVisible()) {
          // 可见的才渲染
          this.paint(renderNode);
        } else {
          // 跳过整个子节点
          callNext();
          this._helpParentRestoreCtx(renderNode);
        }
      });
      if (isWX()) {
        // 兼容小程序
        this.getCtx().draw && this.getCtx().draw();
      }

      this.lastFrameComplete = true;

    }

    renderFPS(){

    }

    readyToRender(element){

      // this.element = generateRenderTree(element)
      this.element = element;

      const options = this.getLayer().options;

      this.lastPaintTime = Date.now();

      if(options && options.animate){
        this.animate();
      }else {
        this.render(this.element);
      }

    }

    requestRepaint(element){
      if(this.isAnimate) return
      // 如果已经有frame在排队等待了 忽略
      // if(!this.lastFrameComplete) return
      // let nextFrameTime = Date.now() - this.lastPaintTime
      // if(nextFrameTime < 16){
      //   setTimeout(() => this.render(this.element),nextFrameTime)
      // }else{
        this.render(this.element);
      // }

    }

    // 小程序需要
    getCanvas() {
      const options = this.getLayer().options;
      return options && options.canvas
    }

    _animate(preTime) {
      const now = Date.now();
      this.render(this.element);
      if (!this.isAnimate) return
      window.requestAnimationFrame(() => this._animate(now));
    }

    /**
     * 不建议使用了
     */
    animate() {
      this.isAnimate = true;
      window.requestAnimationFrame(() => this._animate());
    }

    stopAnimate() {
      this.isAnimate = false;
    }



  }

  function getBorderRadius(element) {
    const { contentWidth, contentHeight } = element.renderStyles;
    let { borderRadius } = element.renderStyles;
    if (borderRadius * 2 > contentWidth) {
      // 如果大于一半，则角不是90度，统一限制最大为一半
      borderRadius = contentWidth / 2;
    }
    if (borderRadius * 2 > contentHeight) {
      borderRadius = contentHeight / 2;
    }
    if (borderRadius < 0) borderRadius = 0;
    return floor(borderRadius)
  }

  // function generateRenderTree(element){
  //   const _root = new RenderNode(element)
  //   let preZ = 0
  //   let pivotZ = 0
  //   let cur = null
  //   let stack = [_root]
  //   while(stack.length){
  //     cur = stack.pop()
  //     if(cur.element.hasChildren()){
  //       cur.children = cur.element._getChildren().map(item => new RenderNode(item))
  //       // sort by zIndex
  //       cur.children = qSort3(cur.children,(pre,pivot) => {
  //         preZ = pre.element.renderStyles.zIndex || 0
  //         pivotZ = pivot.element.renderStyles.zIndex || 0
  //         return preZ - pivotZ
  //       })
  //       Array.prototype.push.apply(stack,cur.children)
  //     }
  //   }
  //   TreeNode.connectChildren(_root)
  //   return _root
  // }

  // class RenderNode extends TreeNode {
  //   constructor(element){
  //     super()
  //     this.element = element
  //   }
  // }

  class Layer {
    constructor(ctx, options) {
      this.ctx = ctx;
      this.node = null;
      this.isAnimate = false;
      this.nodeList = [];
      this.p2cList = [];
      this.c2pList = [];
      this.renderList = [];
      this.options = options;
      this.eventManager = new EventManager(options);
      this.render = new CanvasRender(this);
    }

    update(ctx, options) {
      this.ctx = ctx;
      this.options = options;
      this.options.renderStyles = options;
      this.node.container = this.options;
    }

    mountNode(node) {
      this.node = node;
      this.node.root = this.node;
      this.node.layer = this;
      this.node.container = this.options;
      // 事件也清空一下，重新挂载
      this.eventManager.clear();
      this.initRender();
    }

    initRender() {
      // for 打印耗时
      const startTime = Date.now();

      TreeNode.connectChildren(this.node);
      this.initP2CList();
      this.initC2PList();

      this.flow();

      // inline-block等还需要再重新排一次，待优化
      // this.reflow()

      this.repaint();

      console.log(`渲染${this.p2cList.length}个元素 耗时 ${(Date.now() - startTime)} ms`);
    }

    initP2CList() {
      // 广度优先
      this.p2cList = breadthFirstSearch(this.node);
    }

    initC2PList() {
      this.c2pList = breadthFirstSearchRight(this.node);
    }


    flow(node = this.node) {
      for (let i = 0; i < this.p2cList.length; i++) {
        this.p2cList[i].init();
      }

      this.reflow();
    }

    initPaintList() {
      // 这里实现index
      this.renderList = this.nodeList;
    }

    reflow(node = this.node) {

      for (let i = 0; i < this.c2pList.length; i++) {
        this.c2pList[i]._initWidthHeight();
      }

      for (let i = 0; i < this.p2cList.length; i++) {
        this.p2cList[i]._initPosition();
      }
    }

    reflowElement(element){
      // 如果有line，则需要重第一个开始
      let target = element;
      while(target && target.line){
        target = target.parent;
      }
      const p2cList = breadthFirstSearch(element);
      for(let i = 0; i<p2cList.length; i++){
        p2cList[i]._initStyles();
      }

      // if(!element.isInFlow()){
      //   for(let i = 0; i<p2cList.length; i++){
      //     p2cList[i]._initPosition()
      //   }
      // }else{
        this.onElementChange(target.parent || target);
      // }


    }

    onElementRemove(element) {
      this.eventManager.removeElement(element);
      this.initC2PList();
      this.initP2CList();
      this.onElementChange(element);
    }

    onElementAdd(element) {
      TreeNode.connectChildren(element);
      this.initC2PList();
      this.initP2CList();
      breadthFirstSearch(element).forEach(item => item.init());
      this.onElementChange(element);
    }

    // 元素变化后调用，尽可能少重排重绘
    onElementChange(element) {
      // 所有子元素
      const children = breadthFirstSearchRight(element);
      for (let i = 0; i < children.length; i++) {
        children[i]._initWidthHeight();
      }

      walkParent(element, (parent,callbreak) => {
        parent._initWidthHeight();
        if(parent.type === 'scroll-view') callbreak();
      });

      for (let i = 0; i < this.p2cList.length; i++) {
        this.p2cList[i]._initPosition();
      }
      this.repaint();
    }

    callBeforePaint(){
      for (let i = 0; i < this.p2cList.length; i++) {
        this.p2cList[i].beforePaint && this.p2cList[i].beforePaint();
      }
    }

    /**
     * 可以给定element，则只会重绘element所在的区域
     * @param {Element} element
     */
    repaint(element = this.node) {
      if (isWX()) {
        // 微信环境下始终重绘整个树
        element = this.node;
      }
      if (!element.isInFlow()) element = this.node;

      this.callBeforePaint();

      this.render.readyToRender(this.node);
    }

    animate(){
      console.warn('use [animate] option instead!');
    }

    getElementBy(){
      return this.node.getElementBy(...arguments)
    }

  }

  class ScrollView extends View {

    constructor(options, children) {
      const {styles,...rest} = options;
      super(rest, children);
      this.options.styles = {
        direction:styles.direction || 'y'
      };
      // 外面包裹一层容器，内层的滚动
      options.styles.overflow = 'hidden';
      this.type = 'scroll-view';
      this._scrollView = new View(options, [this]);
      this._scrollView.type = 'scroll-view-container';
      this.visibleIndex = null;
      this.renderOnDemand = options.attrs && options.attrs.renderOnDemand || false;
      return this._scrollView
    }

    _getDefaultStyles() {
      return {
        ...STYLES.DEFAULT_STYLES,
        direction: 'y',
      }
    }

    beforePaint() {
      this.initChildrenVisible();
    }

    _initWidthHeight(){
      super._initWidthHeight();
      // 这里需要父级款高度，但是外层必须是exact
      this.initScroll();
    }

    _paint() {
      this.getRender()._drawBackground(this);
      this.getRender()._drawScroll(this);
      this.getRender()._drawBox(this);
    }

    init() {
      super.init();
      this.addEventListener();
      const { height, width} = this._scrollView.styles;
      const { direction } = this.styles;
      if (direction.match('y')) {
        if (isAuto(height)) {
          // 必须设置
          console.error('scroll-view 必须设置明确的高度');
        } else {
          this.styles.height = 'auto';
          this.renderStyles.height = 'auto';
        }
      }
      if (direction.match('x')) {
        if (isAuto(width)) {
          // 必须设置
          console.error('scroll-view 必须设置明确的宽度');
        } else {
          this.styles.width = 'auto';
          this.renderStyles.width = 'auto';
        }
      }
    }

    addEventListener() {
      // 监听滚动
      this.currentScrollX = 0;
      this.currentScrollY = 0;
      let direction = this.styles.direction;
      let startX = 0;
      let startY = 0;
      let lastStartX = 0;
      let lastStartY = 0;
      let startMove = false;
      let offsetX = 0;
      let offsetY = 0;
      let speedX = 0;
      let speedY = 0;
      let glideInterval = null;
      let resistanceX = 1;
      let resistanceY = 1;

      this.getLayer().eventManager.EVENTS.forEach(eventName => {
        this.getLayer().eventManager.addEventListener(eventName,(e) => {
          if (direction.match('y')) {
            e.relativeY -= this.currentScrollY;
          }
          if (direction.match('x')) {
            e.relativeX -= this.currentScrollX;
          }
        }, this._scrollView, true);
      });

      this.getLayer().eventManager.addEventListener('mousewheel',(e) => {
        if (!this.scrollBy(e.deltaX,e.deltaY)) {
          this.scrollTo({x:e.deltaX<=0?this.maxScrollX:0,y:e.deltaY<=0?this.maxScrollY:0});
        }else {
          e.stopPropagation();
        }
      },this._scrollView);

      this.getLayer().eventManager.addEventListener('touchstart',(e) => {
        e.stopPropagation();
        startX = e.x;
        startY = e.y;
        lastStartX = startX;
        lastStartY = startY;
        startMove = true;
        clearInterval(glideInterval);
      }, this._scrollView);
      this.getLayer().eventManager.addEventListener('touchmove',(e) => {
        if (startMove) {
          e.stopPropagation();
          offsetX = (e.x - startX);
          offsetY = (e.y - startY);
          if (this.scrollBy(offsetX, offsetY)) {
            lastStartX = startX;
            lastStartY = startY;
            startX = e.x;
            startY = e.y;
          }
        }
      }, this._scrollView);
      this.getLayer().eventManager.addEventListener('touchend',(e) => {
        if (startMove) {
          startMove = false;

          speedX = (e.x - lastStartX);
          speedY = (e.y - lastStartY);
          resistanceX = -speedX * 0.02;
          resistanceY = -speedY * 0.02;
          clearInterval(glideInterval);
          glideInterval = setInterval(() => {
            if (!this.scrollBy(speedX, speedY)) {
              this.scrollTo(this.currentScrollX + speedX,this.currentScrollY + speedY);
              clearInterval(glideInterval);
            }
            speedX += resistanceX;
            speedY += resistanceY;
            if (speedX * speedX <= 0.05 && speedY * speedY <= 0.05) {
              speedX = 0;
              speedY = 0;
              clearInterval(glideInterval);
            }
          }, 16);
        }
      }, this._scrollView);
    }

    initScroll(){
      const { contentWidth: offsetWidth, contentHeight: offsetHeight } = this._scrollView.renderStyles;
      const { width: scrollWidth, height: scrollHeight, direction } = this.renderStyles;
      this.maxScrollX = scrollWidth - offsetWidth;
      this.maxScrollY = scrollHeight - offsetHeight;
    }

    calcScrollBoundX(offsetX) {
        if ((- this.currentScrollX - offsetX) > this.maxScrollX) {
          return false
        } else if (this.currentScrollX + offsetX > 0) {
          return false
        }

      return true
    }

    calcScrollBoundY(offsetY) {
        if ((- this.currentScrollY - offsetY) > this.maxScrollY) {
          return false
        } else if (this.currentScrollY + offsetY > 0) {
          return false
        }

      return true
    }

    scrollByX(offsetX) {
      if (!this.renderStyles.direction.match('x')) return false
      if (this.calcScrollBoundX(offsetX)) {
        this.currentScrollX += offsetX;
        return true
      } else {
        return false
      }
    }

    scrollByY(offsetY) {
      if (!this.renderStyles.direction.match('y')) return false
      if (this.calcScrollBoundY(offsetY)) {
        this.currentScrollY += floor(offsetY);
        this.calcChildrenVisible();
        // this.getLayer().repaint(this._scrollView)
        return true
      } else {
        return false
      }
    }

    scrollBy(offsetX, offsetY) {
      // 这里要两个都运行，所以不要用短路
      if (this.scrollByX(offsetX) | this.scrollByY(offsetY)) {
        this.getRender().requestRepaint(this._scrollView);
        return true
      }
      return false
    }

    scrollTo({x,y}) {
      if(isExact(x) && this.maxScrollX>0){
        x= x;
        if(x>this.maxScrollX) x = this.maxScrollX;
        this.currentScrollX = -floor(x);
      }
      if(isExact(y) && this.maxScrollY>0){
        y= y;
        if(y>this.maxScrollY) y = this.maxScrollY;
        this.currentScrollY = -floor(y);
      }
      this.initChildrenVisible();
      this.getRender().requestRepaint(this._scrollView);
    }

    // TODO:
    initChildrenVisible() {
      if (!this.renderOnDemand) return

      // console.log('==============')
      const children = this._getChildrenInFlow();
      // 左
      for (let i = 0; i < children.length; i++) {
        if (this.isElementInViewport(children[i])) {
          this.visibleIndex = [i, -1];
          break
        } else {
          children[i].visible = false;
        }
      }

      // 右
      for (let i = children.length - 1; i >= 0; i--) {
        if (this.isElementInViewport(children[i])) {
          this.visibleIndex[1] = i;
          break
        } else {
          children[i].visible = false;
        }
      }

      // 中间
      for (let i = this.visibleIndex[0]; i <= this.visibleIndex[1]; i++) {
        children[i].visible = true;
      }
    }

    // 只用计算两头
    // 数据量时能显著提高效率
    // 滚动太快会有问题，暂时使用上面的init
    calcChildrenVisible() {
      if (!this.renderOnDemand) return
      const children = this._getChildrenInFlow();
      const head = generateSiblingNodeIndex(this.visibleIndex[0], 5);
      const foot = generateSiblingNodeIndex(this.visibleIndex[1], 5);
      let visibleIndex = [];
      for (let i = head[0]; i <= head[head.length - 1]; i++) {
        if (children[i]) {
          if (this.isElementInViewport(children[i])) {
            children[i].visible = true;
            if (!visibleIndex.length) {
              visibleIndex.push(i);
            }
          } else {
            children[i].visible = false;
          }
        }
      }
      for (let i = foot[foot.length - 1]; i >= foot[0]; i--) {
        if (children[i]) {
          if (this.isElementInViewport(children[i])) {
            children[i].visible = true;
            if (visibleIndex.length === 1) {
              visibleIndex.push(i);
            }
          } else {
            children[i].visible = false;
          }
        }
      }
      this.visibleIndex = visibleIndex;
    }

    isElementInViewport(element) {
      if (this.styles.direction.match('y')) {
        return ((element.y + element.renderStyles.height + this.currentScrollY) > this._scrollView.contentY)
          && ((element.y + this.currentScrollY) < this._scrollView.contentY + this._scrollView.renderStyles.contentHeight)
      } else {
        return true
        // return ((element.x + element.renderStyles.width + this.currentScroll) > this._scrollView.contentX)
        // && ((element.x + this.currentScroll) < this._scrollView.contentX + this._scrollView.renderStyles.contentWidth)
      }
    }

  }


  function generateSiblingNodeIndex(index, offset) {
    let start = index - offset;
    let end = index + offset;
    let list = [];
    for (let i = start; i <= end; i++) {
      list.push(i);
    }
    return list
  }

  /**
   * 生成一个element tree
   * @param {String} name
   * @param {Function} options
   */

  const elementFactory = {};
  //
  registerComponent('view', (options, children) => new View(options, children));
  registerComponent('text', (options, children) => new Text(options, children));
  registerComponent('image', (options, children) => new $Image(options, children));
  registerComponent('scroll-view', (options, children) => new ScrollView(options, children));
  registerComponent('scrollview', (options, children) => new ScrollView(options, children));

  function createElement(model) {
    // 生成树
    function c(name, options = {}, children = []) {
      // if (arguments.length < 3) {
      //   throw Error(`Element [${name}]: need 3 argument but get 2`)
      // }
      let _element = null;
      let _children = children;
      if (elementFactory[name]) {
        // if (typeof children === 'string' && name !== 'text') {
        //   // 支持text简写
        //   _children = new Text({}, children)
        // } else if (!Array.isArray(children)) {
        //   throw Error(`Element [${name}]:Children must be type of Array!`)
        // }
        _element = elementFactory[name](options, _children, c);
      } else {
        throw Error(`Unknown tag name [${name}] !`)
      }
      return _element
    }
    const _model = model(c);
    // 挂载children
    return _model
  }

  function createLayer(ctx, options) {
    return new Layer(ctx, options)
  }

  // 注册全局组件
  function registerComponent(name, factory) {
    if (elementFactory[name]) {
      throw Error(`Already exist tag name [${name}] !`)
    }
    elementFactory[name] = factory;
  }

  const ef = {
    createLayer,
    createElement,
    component: registerComponent,
    View,
    Text,
    Image: $Image,
    Layer,
    ScrollView,
    mergeOptions
  };

  return ef;

})));
