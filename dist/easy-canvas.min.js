(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.easyCanvas = factory());
}(this, (function () { 'use strict';

  const DISPLAY = {
    BLOCK: 'block',
    INLINE_BLOCK: 'inline-block',
    INLINE: 'inline', // 用户不能设置inline，text默认为inline
    FLEX: 'flex',
    NONE: 'none'
  };

  const WIDTH = {
    AUTO: 'auto',
    OUTER: '100%'
  };

  const POSITION = {
    ABSOLUTE: 'absolute',
    FIXED: 'fixed',
    RELATIVE: 'relative',
    STATIC: 'static'
  };

  const TEXT_ALIGN = {
    LEFT: 'left',
    RIGHT: 'right',
    CENTER: 'center'
  };

  const FLEX_DIRECTION = {
    ROW: 'row',
    COLUMN: 'column'
  };

  const DEFAULT_STYLES = {
    display: DISPLAY.BLOCK,
    fontSize: 14,
    fontWeight: 400,
    fontFamily: "Microsoft Yahei",
    color: '#000',
    paddingTop: 0,
    paddingBottom: 0,
    paddingLeft: 0,
    paddingRight: 0,
    marginTop: 0,
    marginBottom: 0,
    marginLeft: 0,
    marginRight: 0,
    height: WIDTH.AUTO,
    borderRadius: 0,
    lineCap: 'square',
    flexDirection: FLEX_DIRECTION.ROW,
    verticalAlign: 'top',
    textAlign:'left',
    justifyContent: 'flex-start',
    alignItems: 'flex-start',
    whiteSpace: 'normal',
    zIndex: 1
  };

  var STYLES = {
    DISPLAY,
    WIDTH,
    POSITION,
    DEFAULT_STYLES,
    TEXT_ALIGN,
    FLEX_DIRECTION
  };

  function isExact(num) {
    return typeof num === 'number'
  }

  function isAuto(num) {
    return num === 'auto'
  }

  function isOuter(num) {
    if (typeof num !== 'string') return
    return num.match('%')
  }

  function parseOuter(num) {
    let _n = parseInt(num.replace('%', ''));
    return (isNaN(_n) || _n < 0) ? 0 : (_n / 100)
  }


  function walk(element, callback) {
    callback(element);
    if (element.hasChildren()) {
      element._getChildren().forEach(child => {
        walk(child, callback);
      });
    }
  }


  function isWX() {
    return !window
  }

  function isEndNode(el) {
    return el.parent && !el.next && !el.hasChildren()
  }

  function breadthFirstSearch(node) {

    var nodes = [];

    if (node != null) {

      var queue = [];

      queue.unshift(node);

      while (queue.length != 0) {

        var item = queue.shift();

        nodes.push(item._generateRender());

        var children = item._getChildren();

        for (var i = 0; i < children.length; i++)
          queue.push(children[i]._generateRender());

      }

    }

    return nodes;

  }

  function breadthFirstSearchRight(node) {

    var nodes = [];

    if (node != null) {

      var queue = [];

      queue.unshift(node);

      while (queue.length != 0) {

        var item = queue.shift();

        nodes.push(item._generateRender());

        var children = item._getChildren();

        for (var i = children.length - 1; i >= 0; i--)
          queue.push(children[i]._generateRender());

      }

    }

    return nodes;

  }

  class Line {
    constructor() {
      this.width = 0;
      this.height = 0;
      this.contentWidth = 0; // 右边界
      this.y = 0; // 上
      this.doorClosed = false; // 是否允许加入
      this.outerWidth = 0;
      this.container = null;
      this.elements = [];
      this.start = null; // 起点，行最左边第一个
      this.end = null; // 结束
      this.offsetX = 0;
      this.id = Math.random();
    }

    bind(el) {
      this.container = el.parent;
      this.initHeight(el);
      this.outerWidth = el.parent && isAuto(el.parent.styles.width) ? Infinity : el.parent.renderStyles.contentWidth;

      this.start = el;
      this.add(el);
    }

    initHeight(el) {
      this.height = el.parent && el.parent.renderStyles.lineHeight || 0;
    }

    initLayout(el) {
      this.right = el._getContainerLayout().contentX;
      this.y = this.getPreLineBottom(el);
    }

    refreshElementPosition(el) {
      if (this.start === el) {
        this.initLayout(el);
      }
      // 刷新位置，首先以左边计算
      el.x = this.right + this.offsetX;
      el.y = this.y + this.getOffsetY(el);
      // + (this.height - el.renderStyles.height) / 2
      this.right += el.renderStyles.width;

    }

    getOffsetY(el) {
      if (el.renderStyles.verticalAlign === 'bottom') {
        return (this.height - el.renderStyles.height)
      } else if (el.renderStyles.verticalAlign === 'middle') {
        return (this.height - el.renderStyles.height) / 2
      } else {
        return 0
      }
    }


    add(el) {
      this.elements.push(el);
      el.line = this;
      this.refreshWidthHeight(el);

      if (!el.next) {
        this.closeLine();
      }
    }

    refreshWidthHeight(el) {
      if (el.renderStyles.height > this.height) {
        this.height = el.renderStyles.height;
      }

      this.width += el.renderStyles.width;
    }

    canIEnter(el) {
      if ((el.renderStyles.width + this.width) > this.outerWidth) {
        this.closeLine();
        return false
      } else {
        return true
      }
    }

    closeLine() {
      // new line
      this.end = this.elements[this.elements.length - 1];
      this.refreshXAlign();

    }

    getPreLineBottom(el) {
      if (el.pre) {
        if (el.pre.line) {
          return el.pre.line.height + el.pre.line.y
        } else {
          return el._getPreLayout().y + el._getPreLayout().height
        }
      } else {
        return el._getContainerLayout().contentY
      }
    }

    refreshXAlign() {
      if (this.outerWidth > 5000) return
      if (!this.end.parent) return
      let offsetX = this.outerWidth - this.width;
      if (this.end.parent.renderStyles.textAlign === 'center') {
        offsetX = offsetX / 2;
      } else if (this.end.parent.renderStyles.textAlign === 'left') {
        offsetX = 0;
      }
      this.offsetX = offsetX;
    }
  }

  class FlexBox extends Line {
    constructor() {
      super();
      this.exactValue = 0;
      this.flexTotal = 0;
    }

    closeLine() {
      super.closeLine();
      this.calcFlex();
    }

    add(el) {
      if (isExact(el.styles.flex)) {
        this.flexTotal += el.styles.flex;
      } else if (isExact(el.styles.width)) {
        this.exactValue += el.styles.width;
      }
      super.add(el);
    }

    initHeight() {
      this.height = 0;
    }

    calcFlex() {
      const { contentWidth: containerWidth } = this.container.renderStyles;
      this.elements.forEach(child => {
        if (isExact(child.styles.flex)) {
          child.renderStyles.width = (child.styles.flex / this.flexTotal) * (containerWidth - this.exactValue);
          child._refreshContentWithLayout();
        }
      });
    }

    refreshXAlign() {
      if (!this.end.parent) return
      let offsetX = this.outerWidth - this.width;
      if (this.end.parent.renderStyles.justifyContent === 'center') {
        offsetX = offsetX / 2;
      } else if (this.end.parent.renderStyles.justifyContent === 'flex-start') {
        offsetX = 0;
      }
      this.offsetX = offsetX;
    }

    getOffsetY(el) {
      if (el.renderStyles.alignSelf === 'flex-end') {
        return (this.container.renderStyles.contentHeight - el.renderStyles.height)
      } else if (el.renderStyles.alignSelf === 'center') {
        return (this.container.renderStyles.contentHeight - el.renderStyles.height) / 2
      } else {
        return 0
      }
    }
  }

  /**
   * Element类实现盒模型以及定位，不具备绘制
   * 其他类继承实现
   *
   */




  class Element {
    constructor(options, children) {
      this.options = Object.assign({ attrs: {}, styles: {}, on: {} }, options);
      this.children = children;
      this.styles = null;
      this.parent = null;
      this.renderStyles = null;
      this.x = 0;
      this.y = 0;
      this.pre = null;
      this.next = null;
      this.render = null;
      this.root = null;
      this.container = null;
      // this.init()
    }

    init() {
      this._initStyles();
      this.initEvent();
    }

    initEvent() {
      const { click } = this.options.on;
      if (click) {
        const { click } = this.options.on;
        this.getLayer().eventManager.onClick(click, this);
      }
    }

    removeEvent() {
      this.getLayer().eventManager.removeElement(this);
    }

    getLayer() {
      return this.root.layer
    }

    mount(layer) {
      layer.mountNode(this);
    }

    _restore(callback) {
      this.getCtx().save();
      callback();
      this.getCtx().restore();
    }

    _path(callback) {
      this.getCtx().beginPath();
      callback();
      this.getCtx().closePath();
    }

    _initStyles() {
      this.styles = Object.assign({}, this._getDefaultStyles(), this._getParentStyles(this.options.styles), this.options.styles || {});

      this._completeStyles();

      this._initRenderStyles();
    }

    _initRenderStyles() {
      const renderStyles = { ...this.styles };
      const parentWidth = this._getContainerLayout().contentWidth;
      const parentHeight = this._getContainerLayout().contentHeight;

      if (isAuto(renderStyles.width)) {
        renderStyles.width = 0;
      } else if (isOuter(renderStyles.width)) {
        renderStyles.width = parseOuter(renderStyles.width) * parentWidth;
      }

      if (isAuto(renderStyles.height)) {
        renderStyles.height = 0;
      } else if (isOuter(renderStyles.height)) {
        renderStyles.height = parseOuter(renderStyles.height) * parentHeight;
      }

      if (!renderStyles.width) renderStyles.width = 0;
      if (!renderStyles.height) renderStyles.height = 0;


      // 初始化contentWidth
      renderStyles.contentWidth = renderStyles.width - renderStyles.paddingLeft - renderStyles.paddingRight - renderStyles.marginLeft - renderStyles.marginRight - this._getTotalBorderWidth(renderStyles);
      renderStyles.contentHeight = renderStyles.height - renderStyles.paddingTop - renderStyles.paddingBottom - renderStyles.marginTop - renderStyles.marginBottom - this._getTotalBorderWidth(renderStyles);
      this.renderStyles = renderStyles;

      if (this._InFlexBox()) {
        this._bindFlexBox();
      }
    }

    /**
     * 需要继承的styles放在这里
     */
    _getParentStyles(curStyles) {
      let { textAlign, lineHeight, fontSize, color, fontFamily, alignItems } = this.parent && this.parent.styles || {};
      let extendStyles = {};
      // if (textAlign) extendStyles.textAlign = textAlign
      if (lineHeight) extendStyles.lineHeight = lineHeight;
      if (fontSize) extendStyles.fontSize = fontSize;
      if (color) extendStyles.color = color;
      if (fontFamily) extendStyles.fontFamily = fontFamily;
      if (alignItems && !curStyles.alignSelf) extendStyles.alignSelf = alignItems;
      return extendStyles
    }

    _completeStyles() {
      this._completeFlex();

      this._completeWidth();

      this._completeBorder();

      this._completeFont();

    }

    /**
     * borderwidth到各个边
     */
    _completeBorder() {
      let { borderWidth, borderLeftWidth, borderRightWidth, borderBottomWidth, borderTopWidth, borderRadius } = this.styles;
      if (!borderWidth) {
        this.styles.borderWidth = 0;
        borderWidth = 0;
      }
      if (Array.isArray(borderWidth)) {
        this.styles.borderTopWidth = borderWidth[0];
        this.styles.borderRightWidth = borderWidth[1];
        this.styles.borderBottomWidth = borderWidth[2];
        this.styles.borderLeftWidth = borderWidth[3];
      } else {
        if (!borderLeftWidth) {
          this.styles.borderLeftWidth = borderWidth;
        }
        if (!borderRightWidth) {
          this.styles.borderRightWidth = borderWidth;
        }
        if (!borderBottomWidth) {
          this.styles.borderBottomWidth = borderWidth;
        }
        if (!borderTopWidth) {
          this.styles.borderTopWidth = borderWidth;
        }
      }
      if (borderRadius) {
        this.styles.overflow = 'hidden';
      }
    }

    _completeWidth() {
      if (!this.styles.width) {
        if (this.styles.display === STYLES.DISPLAY.INLINE_BLOCK || this.styles.display === STYLES.DISPLAY.INLINE || !this.isInFlow()) {
          this.styles.width = STYLES.WIDTH.AUTO;
        } else if (this.styles.display === STYLES.DISPLAY.BLOCK || this.styles.display === STYLES.DISPLAY.FLEX) {
          this.styles.width = STYLES.WIDTH.OUTER;
        } else {
          this.styles.width = 0;
        }
      }
    }

    _completeFont() {
      if (this.styles.fontSize && !this.styles.lineHeight) {
        this.styles.lineHeight = this.styles.fontSize * 1.4;
      } else if (!this.styles.lineHeight) {
        this.styles.lineHeight = 14;
      }
    }

    _completeFlex() {
      if (this.parent && this.parent.styles.display === STYLES.DISPLAY.FLEX) {
        // flex布局内 width 和flex需要有一个
        if (!this.styles.width && !this.styles.flex) {
          this.styles.flex = 1;
        }
      }
    }

    _getDefaultStyles() {
      return STYLES.DEFAULT_STYLES
    }

    hasChildren() {
      return Array.isArray(this.children) && this.children.length ? true : false
    }

    _getChildren() {
      return this.hasChildren() ? this.children : []
    }

    // 获取文档流中的子节点
    _getChildrenInFlow() {
      return this._getChildren().filter(item => item.isInFlow())
    }

    // 是否在文档流中
    isInFlow() {
      const { position, display } = this.styles;
      return position !== STYLES.POSITION.ABSOLUTE && position !== STYLES.POSITION.FIXED
    }

    _setParent(element) {
      this.parent = element;
      this.root = element.root;
    }

    _setSibling(pre, next) {
      this.pre = pre;
      this.next = next;
    }

    _generateRender() {
      return this
    }

    getCtx() {
      return this.root.layer.ctx
    }

    /**
     * 实现文档流 需要知道上一个兄弟节点
     */
    _reflow() {


    }

    // paint队列执行
    _repaint() {
      this.getCtx().save();

      this._drawBox();

      this._drawBackground();

      this._drawContent();

    }

    // 栈
    _afterPaint() {
      // 这里通过this.ctx栈实现了overflow
      // 第一步判断没有子元素，绘制完成即restore 有子元素需要子元素全部绘制完毕再restore
      if (!this.hasChildren()) {
        this.getCtx().restore();
      }

      // 如果到了层级的最后一个 释放父级的stack
      if (isEndNode(this)) {
        // 首先释放第一层父级
        this.getCtx().restore();
        let cur = this.parent;
        while (cur && !cur.next) {
          // 如果父级也是同级最后一个，再闭合上一个
          this.getCtx().restore();
          cur = cur.parent;
        }
      }
    }

    _drawBox() {

    }

    _drawContent() {

    }

    _drawBackground() {

    }

    _initWidthHeight() {
      const { width, height, display, flex, marginLeft, marginRight, marginTop, marginBottom } = this.styles;
      const layout = this._measureLayout();
      // 初始化宽度高度
      if (isAuto(width)) {
        this.renderStyles.contentWidth = layout.width;
      }

      if (isAuto(height)) {
        // 不填就是auto
        this.renderStyles.contentHeight = layout.height;
      }

      this._refreshLayoutWithContent();

      if (display === STYLES.DISPLAY.INLINE_BLOCK) {
        // 如果是inline-block  这里仅计算高度
        this._bindLine();
      } else if (this._InFlexBox()) {
        this.line.refreshWidthHeight(this);
      }
    }

    _initPosition() {
      const { contentX, contentY, contentWidth, contentHeight } = this._getContainerLayout();
      const { paddingLeft, paddingTop, borderLeftWidth, borderTopWidth, marginLeft, marginTop } = this.renderStyles;
      // 初始化ctx位置
      if (!this.isInFlow()) {
        // 不在文档流中
        const { top, bottom, right, left, width, height } = this.renderStyles;
        if (isExact(top)) {
          this.y = contentY + top;
        } else if (isExact(bottom)) {
          this.y = contentY + contentHeight - bottom - height;
        }

        if (isExact(left)) {
          this.x = contentX + left;
        } else if (isExact(right)) {
          this.x = contentX + contentWidth - right - width;
        }
      } else if (this._InFlexBox()) {
        this.line.refreshElementPosition(this);
      } else if (this.renderStyles.display === STYLES.DISPLAY.INLINE_BLOCK) {
        // inline-block到line里计算
        // this._bindLine()
        this.line.refreshElementPosition(this);
      } else {
        this.x = contentX;
        this.y = this._getPreLayout().y + this._getPreLayout().height;
      }
      this.contentX = this.x + paddingLeft + borderLeftWidth + marginLeft;
      this.contentY = this.y + paddingTop + borderTopWidth + marginTop;
    }

    _InFlexBox() {
      if (!this.parent) return false
      if (this.parent && this.parent.renderStyles.display === STYLES.DISPLAY.FLEX) return true
    }


    // 父元素根据子元素撑开content后，再计算width
    _refreshLayoutWithContent() {
      this.renderStyles.height = this.renderStyles.contentHeight + this.renderStyles.paddingTop + this.renderStyles.paddingBottom + this.renderStyles.marginTop + this.renderStyles.marginBottom + this._getTotalBorderWidth();
      this.renderStyles.width = this.renderStyles.contentWidth + this.renderStyles.paddingLeft + this.renderStyles.paddingRight + this.renderStyles.marginLeft + this.renderStyles.marginRight + this._getTotalBorderWidth();
    }

    // 父元素根据子元素撑开content后，再计算width
    _refreshContentWithLayout() {
      this.renderStyles.contentHeight = this.renderStyles.height - this.renderStyles.paddingTop - this.renderStyles.paddingBottom - this.renderStyles.marginTop - this.renderStyles.marginBottom - this._getTotalBorderWidth();
      this.renderStyles.contentWidth = this.renderStyles.width - this.renderStyles.paddingLeft - this.renderStyles.paddingRight - this.renderStyles.marginLeft - this.renderStyles.marginRight - this._getTotalBorderWidth();
    }

    _getTotalBorderWidth(renderStyles = this.renderStyles) {
      return renderStyles.borderLeftWidth + renderStyles.borderRightWidth + renderStyles.borderTopWidth + renderStyles.borderBottomWidth
    }

    _bindLine() {
      if (this.pre && this.pre.line && this.pre.line.canIEnter(this)) {
        this.pre.line.add(this);
      } else {
        // 新行
        new Line().bind(this);
      }
    }

    _bindFlexBox() {
      if (this.pre && this.pre.line) {
        this.pre.line.add(this);
      } else {
        // 新行
        new FlexBox().bind(this);
      }
    }

    _getContainerLayout() {
      let container = this.parent;
      if (this.styles.position === STYLES.POSITION.STATIC) ;
      if (!container) {
        // root
        container = {
          renderStyles: {
            width: this.container.width,
            height: this.container.height,
            paddingTop: 0,
            paddingBottom: 0,
            paddingLeft: 0,
            paddingRight: 0,
            marginLeft: 0,
            marginRight: 0,
            marginTop: 0,
            marginBottom: 0,
            contentWidth: this.container.width,
            contentHeight: this.container.height
          },
          x: 0,
          y: 0,
          contentX: 0,
          contentY: 0
        };
      }
      return {
        width: container.renderStyles.width,
        height: container.renderStyles.height,
        x: container.x,
        y: container.y,
        paddingTop: container.renderStyles.paddingTop,
        paddingBottom: container.renderStyles.paddingBottom,
        paddingLeft: container.renderStyles.paddingLeft,
        paddingRight: container.renderStyles.paddingRight,
        marginLeft: container.renderStyles.marginLeft,
        marginRight: container.renderStyles.marginRight,
        marginTop: container.renderStyles.marginTop,
        marginBottom: container.renderStyles.marginBottom,
        contentX: container.contentX,
        contentY: container.contentY,
        contentWidth: container.renderStyles.contentWidth,
        contentHeight: container.renderStyles.contentHeight
      }
    }

    // 这里前一个节点必须在文档流中
    _getPreLayout() {
      let cur = this.pre;
      while (cur && !cur.isInFlow()) {
        cur = cur.pre;
      }
      // 如果没有前一个或者前面的都不在文档流中，获取容器的
      if (cur) {
        return {
          width: cur.renderStyles.width,
          height: cur.renderStyles.height,
          x: cur.x,
          y: cur.y
        }
      } else {
        return {
          width: 0,
          height: 0,
          x: this._getContainerLayout().contentX,
          y: this._getContainerLayout().contentY
        }
      }
    }

    // 计算自身的高度
    _measureLayout() {
      let width = 0; // 需要考虑原本的宽度
      let height = 0;
      this._getChildrenInFlow().forEach(child => {
        if (child.line) {
          if (child.line.start === child) {
            if (child.line.width > width) {
              width = child.line.width;
            }
            height += child.line.height;
          }
        } else if (child.renderStyles.width > width) {
          width = child.renderStyles.width;
          height += child.renderStyles.height;
        } else {
          height += child.renderStyles.height;
        }
      });

      return { width, height }
    }

    // 获取元素，只会找该元素子级
    getElementBy(key, value) {
      let match = [];
      walk(this, (element) => {
        if (element.options.attrs[key] === value) {
          match.push(element);
        }
      });
      return match
    }

    // 添加在最后
    appendChild(element) {
      if (!element instanceof Element) throw Error('Unknown Element type')
      this.children.push(element);
      this.getLayer().mountNode(this.root);
      return element
    }

    //
    prependChild(element) {
      if (!element instanceof Element) throw Error('Unknown Element type')
      this.children.unshift(element);
      this.getLayer().mountNode(this.root);
      return element
    }

    removeChild(element) {
      if (!element instanceof Element) throw Error('Unknown Element type')
      const index = this._getChildren().indexOf(element);
      if (index < 0) throw Error('Element must be the child of parent')
      const pre = this._getChildren()[index - 1];
      const next = this._getChildren()[index + 1];
      if (pre) {
        pre._setSibling(pre.pre, next);
      }
      if (next) {
        next._setSibling(pre, next.next);
      }
      this.children.splice(index, 1);
      element.removeEvent();
      this.getLayer().mountNode(this.root);
    }

    append(element) {
      if (!element instanceof Element) throw Error('Unknown Element type')
      if (!this.parent) throw Error('Can not add element to root level!')
      let children = [];
      this.parent.children.forEach(child => {
        children.push(child);
        if (child === this) {
          children.push(element);
        }
      });
      this.parent.children = children;
      this.getLayer().mountNode(this.root);
    }

    prepend(element) {
      if (!element instanceof Element) throw Error('Unknown Element type')
      if (!this.parent) throw Error('Can not add element to root level!')
      let children = [];
      for (let i = this.parent.children.length - 1; i >= 0; i--) {
        children.unshift(this.parent.children[i]);
        if (this.parent.children[i] === this) {
          children.unshift(element);
        }
      }
      this.parent.children = children;
      this.getLayer().mountNode(this.root);
    }

  }

  class View extends Element {
    _getDefaultStyles() {
      return {
        ...STYLES.DEFAULT_STYLES,
        display: STYLES.DISPLAY.BLOCK
      }
    }

    _completeStyles() {
      super._completeStyles();
      this._completePaddingMargin();
    }

    _completePaddingMargin() {
      if (this.styles.padding) {
        if (isExact(this.styles.padding)) {
          this.styles.paddingLeft = this.styles.padding;
          this.styles.paddingBottom = this.styles.padding;
          this.styles.paddingRight = this.styles.padding;
          this.styles.paddingTop = this.styles.padding;
        } else if (Array.isArray(this.styles.padding)) {
          // 支持数组[10,20]相当于padding:10px 20px;
          if (this.styles.padding.length === 2) {
            this.styles.paddingLeft = this.styles.paddingRight = this.styles.padding[1];
            this.styles.paddingBottom = this.styles.paddingTop = this.styles.padding[0];
          } else if (this.styles.padding.length === 4) {
            this.styles.paddingLeft = this.styles.padding[3];
            this.styles.paddingBottom = this.styles.padding[2];
            this.styles.paddingRight = this.styles.padding[1];
            this.styles.paddingTop = this.styles.padding[0];
          }
        }
      }

      if (isExact(this.styles.margin)) {
        this.styles.marginLeft = this.styles.margin;
        this.styles.marginBottom = this.styles.margin;
        this.styles.marginRight = this.styles.margin;
        this.styles.marginTop = this.styles.margin;
      } else if (Array.isArray(this.styles.margin)) {
        // 支持数组[10,20]相当于padding:10px 20px;
        if (this.styles.margin.length === 2) {
          this.styles.marginLeft = this.styles.marginRight = this.styles.margin[1];
          this.styles.marginBottom = this.styles.marginTop = this.styles.margin[0];
        } else if (this.styles.margin.length === 4) {
          this.styles.marginLeft = this.styles.margin[3];
          this.styles.marginBottom = this.styles.margin[2];
          this.styles.marginRight = this.styles.margin[1];
          this.styles.marginTop = this.styles.margin[0];
        }
      }
    }

    _reflow() {
      super._reflow();
    }

    _repaint() {
      super._repaint();
    }

    _afterPaint() {
      super._afterPaint();
    }

    _drawBackground() {
      const { backgroundColor, contentWidth, contentHeight, paddingLeft, paddingRight, paddingTop, paddingBottom, opacity } = this.renderStyles;
      const ctx = this.getCtx();

      if (isExact(opacity)) {
        // 绘制透明图
        ctx.globalAlpha = opacity;
      }

      this._clip();
      // draw background
      if (backgroundColor) {
        this.getCtx().fillStyle = backgroundColor;
        this.getCtx().fillRect(this.contentX - paddingLeft, this.contentY - paddingTop, contentWidth + paddingLeft + paddingRight, contentHeight + paddingTop + paddingBottom);
      }

      // for debug
      if (this.getLayer().options && this.getLayer().options.debug) {
        this.getCtx().strokeStyle = 'green';
        this.getCtx().strokeRect(this.contentX, this.contentY, this.renderStyles.contentWidth, this.renderStyles.contentHeight);
        // ctx.strokeStyle = '#fff'
        // ctx.strokeText(`${parseInt(this.contentX)} ${parseInt(this.contentY)} ${contentWidth} ${contentHeight}`, this.contentX + 100, this.contentY + 10)

        //
      }
    }

    _drawBox() {

      this._drawRadiusBorder();

    }

    _drawRadiusBorder() {
      if (!(this.renderStyles.borderColor || this.renderStyles.shadowBlur)) return
      const { contentWidth, contentHeight, paddingLeft, paddingTop, borderStyle,
        paddingRight, paddingBottom, shadowBlur, shadowColor, backgroundColor, shadowOffsetX, shadowOffsetY,
        borderLeftWidth, borderRightWidth, borderTopWidth, borderBottomWidth } = this.renderStyles;

      const angle = Math.PI / 2;
      let borderRadius = this._getBorderRadius();


      // 这里是计算画border的位置，起点位置是在线条中间，所以要考虑线条宽度
      let x = this.contentX - this.renderStyles.paddingLeft - borderLeftWidth / 2;
      let y = this.contentY - this.renderStyles.paddingTop - borderTopWidth / 2;
      let w = contentWidth + paddingLeft + paddingRight + (borderLeftWidth + borderRightWidth) / 2;
      let h = contentHeight + paddingTop + paddingBottom + (borderTopWidth + borderBottomWidth) / 2;


      const topBorder = () => {
        // 左上角开始
        this.getCtx().moveTo(x, y + borderRadius);
        borderRadius && this.getCtx().arc(x + borderRadius, y + borderRadius, borderRadius, 2 * angle, 3 * angle);
        this.getCtx().lineTo(x + w - borderRadius, y);
      };
      const rightBorder = () => {
        // 右上角
        // this.getCtx().moveTo(x + w - borderRadius, y)
        borderRadius && this.getCtx().arc(x + w - borderRadius, y + borderRadius, borderRadius, 3 * angle, 4 * angle);
        this.getCtx().lineTo(x + w, y + h - borderRadius);
      };

      const bottomBorder = () => {
        // 右下角
        // this.getCtx().moveTo(x + w, y + h - borderRadius)
        borderRadius && this.getCtx().arc(x + w - borderRadius, y + h - borderRadius, borderRadius, 0, angle);
        this.getCtx().lineTo(x + borderRadius, y + h);
      };

      const leftBorder = () => {
        // 左下角
        borderRadius && this.getCtx().arc(x + borderRadius, y + h - borderRadius, borderRadius, angle, angle * 2);
        this.getCtx().lineTo(x, y + borderRadius);
      };

      this.getCtx().lineCap = this.renderStyles.lineCap;
      this.getCtx().strokeStyle = this.renderStyles.borderColor;

      // 实现虚线
      if (borderStyle && borderStyle !== 'solid') {
        if (Array.isArray(borderStyle)) {
          this.getCtx().setLineDash(borderStyle);
        } else {
          this.getCtx().setLineDash([5, 5]);
        }
      }

      const stroke = (borderWidth) => {
        // 有样式则绘制出来
        this.getCtx().lineWidth = borderWidth;
        this.getCtx().stroke();
      };
      // 绘制boxshadow
      if (shadowColor && shadowBlur) {
        this._restore(() => {
          this._path(() => {
            topBorder();
            rightBorder();
            bottomBorder();
            leftBorder();
          });
          if (isExact(shadowOffsetX)) {
            this.getCtx().shadowOffsetX = shadowOffsetX;
          }
          if (isExact(shadowOffsetY)) {
            this.getCtx().shadowOffsetY = shadowOffsetY;
          }
          this.getCtx().shadowBlur = shadowBlur;
          this.getCtx().shadowColor = shadowColor;
          this.getCtx().fillStyle = shadowColor;
          this.getCtx().fill();
        });
      }
      this._restore(() => {
        this._path(() => {

          x = this.contentX - this.renderStyles.paddingLeft - borderLeftWidth / 2;
          y = this.contentY - this.renderStyles.paddingTop - borderTopWidth / 2;
          w = contentWidth + paddingLeft + paddingRight + (borderLeftWidth + borderRightWidth) / 2;
          h = contentHeight + paddingTop + paddingBottom + (borderTopWidth + borderBottomWidth) / 2;
          if (this.renderStyles.borderTopWidth) {
            topBorder();
            stroke(this.renderStyles.borderTopWidth);
          }
          if (this.renderStyles.borderRightWidth) {
            this.getCtx().moveTo(x + w - borderRadius, y);
            rightBorder();
            stroke(this.renderStyles.borderRightWidth);
          }
          if (this.renderStyles.borderBottomWidth) {
            this.getCtx().moveTo(x + w, y + h - borderRadius);
            bottomBorder();
            stroke(this.renderStyles.borderBottomWidth);
          }
          if (this.renderStyles.borderLeftWidth) {
            this.getCtx().moveTo(x + borderRadius, y + h);
            leftBorder();
            stroke(this.renderStyles.borderLeftWidth);
          }
        });
      });






    }

    _clip() {
      if (this.renderStyles.overflow !== 'hidden') return
      const { contentWidth, contentHeight, paddingLeft, paddingTop,
        paddingRight, paddingBottom, shadowBlur, shadowColor, backgroundColor,
        borderLeftWidth, borderRightWidth, borderTopWidth, borderBottomWidth } = this.renderStyles;

      const angle = Math.PI / 2;

      let borderRadius = this._getBorderRadius();

      // 为了把border也切进去
      let x = this.contentX - this.renderStyles.paddingLeft - borderLeftWidth;
      let y = this.contentY - this.renderStyles.paddingTop - borderTopWidth;
      let w = contentWidth + paddingLeft + paddingRight + borderLeftWidth + borderRightWidth;
      let h = contentHeight + paddingTop + paddingBottom + borderTopWidth + borderBottomWidth;

      const topBorder = () => {
        // 左上角开始
        this.getCtx().moveTo(x, y + borderRadius);
        borderRadius && this.getCtx().arc(x + borderRadius, y + borderRadius, borderRadius, 2 * angle, 3 * angle);
        this.getCtx().lineTo(x + w - borderRadius, y);
      };
      const rightBorder = () => {
        // 右上角
        // this.getCtx().moveTo(x + w - borderRadius, y)
        borderRadius && this.getCtx().arc(x + w - borderRadius, y + borderRadius, borderRadius, 3 * angle, 4 * angle);
        this.getCtx().lineTo(x + w, y + h - borderRadius);
      };

      const bottomBorder = () => {
        // 右下角
        // this.getCtx().moveTo(x + w, y + h - borderRadius)
        borderRadius && this.getCtx().arc(x + w - borderRadius, y + h - borderRadius, borderRadius, 0, angle);
        this.getCtx().lineTo(x + borderRadius, y + h);
      };

      const leftBorder = () => {
        // 左下角
        borderRadius && this.getCtx().arc(x + borderRadius, y + h - borderRadius, borderRadius, angle, angle * 2);
        this.getCtx().lineTo(x, y + borderRadius);
      };

      this._path(() => {
        topBorder();
        rightBorder();
        bottomBorder();
        leftBorder();
      });


      this.getCtx().clip();

    }

    _getBorderRadius() {
      const { contentWidth, contentHeight } = this.renderStyles;
      let { borderRadius } = this.renderStyles;
      if (borderRadius * 2 > contentWidth) {
        // 如果大于一半，则角不是90度，统一限制最大为一半
        borderRadius = contentWidth / 2;
      }
      if (borderRadius * 2 > contentHeight) {
        borderRadius = contentHeight / 2;
      }
      if (borderRadius < 0) borderRadius = 0;
      return borderRadius
    }



  }

  class Text extends Element {
    constructor(options, children) {
      super(options, children);
      this._layout = null; // layout用来保存计算的自身高度
      this._lines = [];
      this.children += '';
    }

    _getDefaultStyles() {
      return {
        ...STYLES.DEFAULT_STYLES,
        display: STYLES.DISPLAY.INLINE_BLOCK,
        width: STYLES.WIDTH.AUTO,
        textAlign: 'left',
      }
    }

    _completeStyles() {
      super._completeStyles();
    }

    _completeWidth() {
      super._completeWidth();

      if (this.styles.textAlign !== 'left' && this.parent && !isAuto(this.parent.styles.width)) {
        this.styles.width = '100%';
      }
    }

    _initLayout() {

      super._initLayout();
    }

    _measureLayout() {
      this._restore(() => {
        this.getCtx().font = this._getFont();
        const { width } = this.getCtx().measureText(this.children);
        this._layout = { width };
        // 微信 夸克 有兼容性问题
        // this._layout.fontHeight = this._layout.actualBoundingBoxAscent || this.renderStyles.fontSize
        this._layout.fontHeight = this.renderStyles.fontSize * 0.8;
        this._layout.height = this.renderStyles.lineHeight;
        this._calcLine();
      });
      return this._layout
    }

    _drawContent() {
      const { color, contentWidth, lineHeight, textAlign, textIndent } = this.renderStyles;
      let x = this.contentX;
      this.getCtx().fillStyle = color;
      this.getCtx().textAlign = textAlign;
      this.getCtx().font = this._getFont();
      if (textAlign === STYLES.TEXT_ALIGN.RIGHT) {
        x = this.contentX + contentWidth;
      } else if (textAlign === STYLES.TEXT_ALIGN.CENTER) {
        x = this.contentX + (contentWidth / 2);
      }
      let _x = x;
      this._lines.forEach((line, index) => {
        if (index === 0 && textIndent) {
          // 第一行实现textIndent
          _x = x + textIndent;
        } else {
          _x = x;
        }
        this.getCtx().fillText(line, _x, (this.contentY + ((lineHeight + this._layout.fontHeight) / 2) + lineHeight * index));
      });
    }

    _getFont() {
      const { fontSize, fontWeight, fontFamily } = this.renderStyles;
      return `${fontWeight} ${fontSize}px ${fontFamily}`
    }

    _calcLine() {
      if (!this.parent || !this.children) return
      const { width: textWidth, height: textHeight } = this._layout;
      const { contentWidth: parentContentWidth } = this.parent.renderStyles;
      const { width: parentWidth } = this.parent.styles;
      // 如果一行宽度够，或者父级宽度是auto
      if ((isExact(parentContentWidth) && parentContentWidth >= textWidth) || parentWidth === STYLES.WIDTH.AUTO) {
        this._lines = [this.children];
      } else {
        this._lines = [];
        let lineIndex = 1;
        let lineText = '';
        let _layout = null;
        for (let i = 0; i < this.children.length; i++) {
          _layout = this.getCtx().measureText(lineText + this.children[i]);
          if (_layout.width > parentContentWidth) {
            if (lineIndex >= this.renderStyles.maxLine) {
              // 最大行数限制 以及maxline省略号实现
              lineText = lineText.substring(0, lineText.length - 2) + '...';
              break
            }
            // 超出了
            this._lines.push(lineText);
            lineText = '';
            lineIndex += 1;

          }

          lineText += this.children[i];
        }
        this._lines.push(lineText);
        this._layout.width = parentContentWidth;
        // 根据lineheihgt更新height
        this._layout.height = this._lines.length * this.renderStyles.lineHeight;
      }
    }
  }

  class $Image extends View {

    init() {
      super.init();
      this._imageInfo = {
        width: 0,
        height: 0,
        sx: 0,
        sy: 0,
        swidth: 0,
        sheight: 0,
        dx: 0,
        dy: 0,
        dwidth: 0,
        dheight: 0
      };
      this._image = null;
      this._loadImage();
    }

    _loadImage() {
      return new Promise((resolve, reject) => {
        loadImage(this.options.attrs.src, this.getLayer().getCanvas())
          .then(({ info, image }) => {
            this._imageInfo = info;
            this._image = image;
            resolve();

            this._layoutImage();

            // // 重新布局绘制
            this.getLayer().reflow();
            this.getLayer().repaint();

            // call load callback
            if (this.options.on && this.options.on.load) {
              this.options.on.load(this);
            }
          });
      })
    }

    _drawContent() {
      if (!this._image) return
      const { contentWidth, contentHeight } = this.renderStyles;
      const { mode } = this.options.attrs;
      const { sx, sy, swidth, sheight, dx, dy, dwidth, dheight, width: imageW, height: imageH } = this._imageInfo;
      if (mode === 'aspectFill') {
        this.getCtx().drawImage(this._image, sx, sy, swidth, sheight, this.contentX, this.contentY, contentWidth, contentHeight);
      } else if (mode === 'aspectFit') {
        this.getCtx().drawImage(this._image, 0, 0, imageW, imageH, dx, dy, dwidth, dheight);
      } else {
        this.getCtx().drawImage(this._image, this.contentX, this.contentY, contentWidth, contentHeight);
      }
    }

    // 计算图片布局
    _layoutImage() {
      const { contentWidth, contentHeight } = this.renderStyles;
      const { mode } = this.options.attrs;
      const { width, height } = this.styles;
      const { width: imageW, height: imageH } = this._imageInfo;
      // 根据用户设置判断图片宽高，目前支持widthfix、heightfix、平铺
      let w = contentWidth;
      let h = contentHeight;
      if (!isAuto(width) && isAuto(height)) {
        // width fix
        w = contentWidth;
        h = getHeightByWidth(w, imageW, imageH);
      } else if (!isAuto(height) && isAuto(width)) {
        // height fix
        h = contentHeight;
        w = getWidthByHeight(h, imageW, imageH);
      } else if (isAuto(width) && isAuto(height)) {
        // auto
        w = imageW;
        h = imageH;
      } else if (mode === 'aspectFill') {
        // 填充
        if ((w / h) > (imageW / imageH)) {
          this._imageInfo.swidth = imageW;
          this._imageInfo.sheight = getHeightByWidth(imageW, w, h);
          this._imageInfo.sx = 0;
          this._imageInfo.sy = (imageH - this._imageInfo.sheight) / 2;
        } else {
          this._imageInfo.sheight = imageH;
          this._imageInfo.swidth = getWidthByHeight(imageH, contentWidth, contentHeight);
          this._imageInfo.sy = 0;
          this._imageInfo.sx = (imageW - this._imageInfo.swidth) / 2;
        }
      } else if (mode === 'aspectFit') {
        if ((w / h) > (imageW / imageH)) {
          this._imageInfo.dwidth = getWidthByHeight(contentHeight, imageW, imageH);
          this._imageInfo.dheight = contentHeight;
          this._imageInfo.dy = this.contentY;
          this._imageInfo.dx = (contentWidth - this._imageInfo.dwidth) / 2 + this.contentX;
        } else {
          this._imageInfo.dheight = getHeightByWidth(contentWidth, imageW, imageH);
          this._imageInfo.dwidth = contentWidth;
          this._imageInfo.dx = this.contentX;
          this._imageInfo.dy = (contentHeight - this._imageInfo.dheight) / 2 + this.contentY;
        }
      } else {
        w = contentWidth;
        h = contentHeight;
      }
      this._layout = { width: w, height: h };
    }

    _measureLayout() {
      if (this._layout) {
        return this._layout
      } else {
        return {
          width: this.renderStyles.width,
          height: this.renderStyles.height
        }
      }
    }

  }

  // canvas可能为空，小程序下必传
  function loadImage(src, canvas) {

    return new Promise((resolve, reject) => {
      let image = null;

      if (isWX()) {
        image = canvas.createImage();
      } else {
        image = new Image();
      }

      image.src = src;
      image.onload = function (e) {
        resolve({
          image,
          info: {
            width: e.target.width,
            height: e.target.height
          }
        });
      };

    })
  }

  function getWidthByHeight(height, originWidth, originHeight) {
    return height / originHeight * originWidth
  }

  function getHeightByWidth(width, originWidth, originHeight) {
    return width / originWidth * originHeight
  }

  class EventManager {

    constructor({ simulateClick = true }) {
      this.clickList = [];
      this.touchstartList = [];
      this.touchmoveList = [];
      this.touchendList = [];
      this.touchStartEvent = null;
      this.simulateClick = simulateClick; // 是否模拟移动端点击事件
    }

    clear() {
      this.clickList = [];
      this.touchstartList = [];
      this.touchmoveList = [];
      this.touchendList = [];
    }

    click(x, y) {
      let event = new Event({ x, y, type: 'click' });
      this._emit(event);
    }

    touchstart(x, y) {
      let event = new Event({ x, y, type: 'touchstart' });
      this.touchStartEvent = event;
      this._emit(event);
    }

    touchmove(x, y) {
      let event = new Event({ x, y, type: 'touchmove' });
      this._emit(event);
    }

    touchend(x, y) {
      let event = new Event({ x, y, type: 'touchend' });
      this._emit(event);
      this.checkClick(event);
    }

    _emit(e) {
      let callbackList = [];
      switch (e.type) {
        case 'click': callbackList = this.clickList; break
        case 'touchstart': callbackList = this.touchstartList; break
        case 'touchmove': callbackList = this.touchmoveList; break
        case 'touchend': callbackList = this.touchendList; break
      }

      // let emitList = []

      // for(let i = callbackList.length-1; i>=0; i--){
      //   if(this.isPointInElement())
      // }

      for (let i = 0; i < callbackList.length; i++) {
        if (this.isPointInElement(e.x, e.y, callbackList[i].element)) {
          if (!e.currentTarget) e.currentTarget = callbackList[i].element;
          callbackList[i].callback(e);
          if (e.cancelBubble) break
        }
      }
    }

    // 待优化
    isPointInElement(x, y, element) {
      let { width, height } = element.renderStyles;
      let _x = x; // 根据scroll-view做转换
      let _y = y;
      let cur = element.parent;
      // 这里实现有点拉跨，每次都会向上遍历看有没有scroll-view
      while (cur) {
        if (cur.type === 'scroll-view' && this._isPointTouchElement(_x,_y,cur)) {
          if (cur.styles.direction === 'x') {
            _x -= cur.currentScroll;
          } else {
            _y -= cur.currentScroll;
          }
        }
        cur = cur.parent;
      }

      return this._isPointTouchElement(_x,_y,element)
    }

    _isPointTouchElement(x,y,element){
      if (x >= element.x && y >= element.y && (x <= element.x + element.renderStyles.width) && (y <= element.y + element.renderStyles.height)) {
        return true
      }
      return false
    }

    createEvent(x, y, type) {

    }

    removeElement(element) {
      this.clickList = this.clickList.filter(item => item.element !== element);
      this.touchstartList = this.touchstartList.filter(item => item.element !== element);
      this.touchmoveList = this.touchmoveList.filter(item => item.element !== element);
      this.touchendList = this.touchendList.filter(item => item.element !== element);
    }

    onClick(callback, element) {
      // 为啥要unshift呢，因为元素是从父级,往子集初始化的
      this.clickList.unshift({ callback, element });
    }

    onTouchStart(callback, element) {
      this.touchstartList.unshift({ callback, element });
    }

    onTouchMove(callback, element) {
      this.touchmoveList.unshift({ callback, element });
    }

    onTouchEnd(callback, element) {
      this.touchendList.unshift({ callback, element });
    }

    // 这里利用touchstart和touchend实现了移动端click事件
    checkClick(event) {
      if (this.touchStartEvent && this.simulateClick) {
        // 判断两点距离
        let { x: startx, y: starty } = this.touchStartEvent;
        let { x: endx, y: endy } = event;
        let distance = ((endy * endy + endx * endx) - (starty * starty + startx * startx));
        if (distance < 10 && distance > -10) {
          this.click(endx, endy);
        }
      }
    }
  }

  class Event {
    constructor({ x, y, type }) {
      this.x = x;
      this.y = y;
      this.scrollX = x; // scroll到每一层scrollview会不断变化
      this.scrollY = y;
      this.type = type;
      this.cancelBubble = false;
      this.currentTarget = null; // 第一个element
    }

    // 阻止冒泡
    stopPropagation() {
      this.cancelBubble = true;
    }
  }

  class Layer {
    constructor(ctx, options) {
      this.ctx = ctx;
      this.node = null;
      this.nodeList = [];
      this.p2cList = [];
      this.c2pList = [];
      this.renderList = [];
      this.options = options;
      this.eventManager = new EventManager(options);
    }

    update(ctx, options) {
      this.ctx = ctx;
      this.options = options;
      this.node.container = this.options;
    }

    mountNode(node) {
      this.node = node;
      this.node.root = this.node;
      this.node.layer = this;
      this.node.container = this.options;
      // 事件也清空一下，重新挂载
      this.eventManager.clear();
      this.initRender();
    }

    initRender() {
      this.connectChildren(this.node);
      this.p2cList = this.getP2CList(this.node);
      this.c2pList = breadthFirstSearchRight(this.node).reverse();
      // this.initPaintList()
      this.initNode();
      console.log(this.p2cList);


      this.flow();

      // inline-block等还需要再重新排一次，待优化
      // this.reflow()

      this.repaint();

    }

    getP2CList(el) {
      // 广度优先
      return breadthFirstSearch(el)

    }

    connectChildren(el) {
      if (el.hasChildren()) {
        let childrenRender = el._getChildren().map((child, index) => {
          // 设置parent
          child._setParent(el);
          // 设置了上一个兄弟节点
          child._setSibling(el._getChildren()[index - 1], el._getChildren()[index + 1]);
          return this.connectChildren(child)
        }).reduce((sum, val) => [...sum, ...val]);
        // childrenRender.reverse()
        return [el._generateRender(), ...childrenRender]
      } else {
        return [el._generateRender()]
      }
    }


    initNode(node = this.node) {
      walk(node, item => {
        item.init();
      });
    }

    flow(node = this.node) {
      this.reflow();
    }

    initPaintList() {
      // 这里实现index
      this.renderList = this.nodeList;
    }

    reflow(node = this.node) {
      for (let i = 0; i < this.c2pList.length; i++) {
        this.c2pList[i]._initWidthHeight();
      }

      for (let i = 0; i < this.p2cList.length; i++) {
        this.p2cList[i]._initPosition();
      }
    }

    /**
     * 可以给定element，则只会重绘element所在的区域
     * @param {Element} element
     */
    repaint(element = this.node) {
      // let width = element.renderStyles.width
      // let height = element.renderStyles.height
      // let x = element.x
      // let y = element.y
      // this.ctx.clearRect(x, y, width, height)
      // walk(element, (item) => {
      //   item._repaint()
      //   item._afterPaint()
      // })

      // this.ctx.clearRect(this.container.x, this.node.y, this.node.renderStyles.width, this.node.renderStyles.height)
      this.ctx.clearRect(0, 0, this.options.width, this.options.height);
      walk(this.node, element => {
        element._repaint();
        element._afterPaint();
      });
      // 兼容小程序
      this.ctx.draw && this.ctx.draw();
    }

    // 小程序需要
    getCanvas() {
      return this.options && this.options.canvas
    }

  }

  class ScrollView extends View {

    constructor(options, children) {
      super(options, children);
      // 外面包裹一层容器，内层的滚动
      options.styles.overflow = 'hidden';
      this.type = 'scroll-view';
      this._scrollView = new View(options, [this]);
      this._scrollView.type = 'scroll-view-container';
      return this._scrollView
    }

    _getDefaultStyles() {
      return {
        ...STYLES.DEFAULT_STYLES,
        direction: 'y',
      }
    }

    init() {
      super.init();
      this.addEventListener();

      const { height, width, direction } = this.styles;
      if (direction === 'y') {
        if (!isAuto(height)) {
          this.styles.height = 'auto';
          this.renderStyles.height = 'auto';
        } else {
          // 必须设置
          console.error('scroll-view 必须设置明确的高度');
        }
      } else if (direction === 'x') {
        if (!isAuto(width)) {
          this.styles.width = 'auto';
          this.renderStyles.width = 'auto';
        } else {
          // 必须设置
          console.error('scroll-view 必须设置明确的宽度');
        }
      }
    }

    addEventListener() {
      // 监听滚动
      this.currentScroll = 0;
      let direction = this.styles.direction;
      let start = 0;
      let lastStart = 0;
      let startMove = false;
      let offset = 0;
      let speed = 0;
      let glideInterval = null;
      let resistance = 1;

      // this.getLayer().eventManager.captureTouch(e => {
      //   if(direction === 'y'){
      //     e.scrollY -= this.currentScroll
      //   }else{
      //     e.scrollX -= this.currentScroll
      //   }
      // },this._scrollView)

      this.getLayer().eventManager.onTouchStart((e) => {
        e.stopPropagation();
        start = e[direction];
        lastStart = start;
        startMove = true;
        clearInterval(glideInterval);
      }, this._scrollView);
      this.getLayer().eventManager.onTouchMove((e) => {
        if (startMove) {
          e.stopPropagation();
          offset = (e[direction] - start);
          if (this.scrollBy(offset)) {
            lastStart = start;
            start = e[direction];
          }
        }
      }, this._scrollView);
      this.getLayer().eventManager.onTouchEnd((e) => {
        if (startMove) {
          startMove = false;
          speed = (e[direction] - lastStart) * 2;
          resistance = -speed * 0.02;
          clearInterval(glideInterval);
          glideInterval = setInterval(() => {
            if (!this.scrollBy(speed)) {
              clearInterval(glideInterval);
            }
            speed += resistance;
            if (speed * speed <= 0.05) {
              speed = 0;
              clearInterval(glideInterval);
            }
          }, 18);
        }
      }, this._scrollView);
    }

    _repaint() {
      // 滚动实现 目前是计算一次重新绘制一次，有需要再优化
      const { direction } = this.renderStyles;
      if (direction === 'y') {
        this.getCtx().translate(0, this.currentScroll);
      } else {
        this.getCtx().translate(this.currentScroll, 0);
      }
      super._repaint();
    }

    calcScrollBound(offset) {
      const { contentWidth: offsetWidth, contentHeight: offsetHeight } = this._scrollView.renderStyles;
      const { width: scrollWidth, height: scrollHeight, direction } = this.renderStyles;
      if (direction === 'y') {
        if ((offsetHeight - this.currentScroll - offset) > scrollHeight) {
          return false
        } else if (this.currentScroll + offset > 0) {
          return false
        }
      } else {
        if ((offsetWidth - this.currentScroll - offset) > scrollWidth) {
          return false
        } else if (this.currentScroll + offset > 0) {
          return false
        }
      }

      return true
    }

    scrollBy(offset) {
      if (this.calcScrollBound(offset)) {
        this.currentScroll += offset;
        this.getLayer().repaint();
        // this.getLayer().repaint(this._scrollView)
        return true
      } else {
        return false
      }
    }

    scrollTo(pos) {

    }

  }

  /**
   * 生成一个element tree
   * @param {String} name
   * @param {Function} options
   */

  const elementFactory = {};
  //
  registerComponent('view', (options, children) => new View(options, children));
  registerComponent('text', (options, children) => new Text(options, children));
  registerComponent('image', (options, children) => new $Image(options, children));
  registerComponent('scroll-view', (options, children) => new ScrollView(options, children));
  registerComponent('scrollview', (options, children) => new ScrollView(options, children));

  function createElement(model) {
    // 生成树
    function c(name, options = {}, children = []) {
      // if (arguments.length < 3) {
      //   throw Error(`Element [${name}]: need 3 argument but get 2`)
      // }
      let _element = null;
      let _children = children;
      if (elementFactory[name]) {
        // if (typeof children === 'string' && name !== 'text') {
        //   // 支持text简写
        //   _children = new Text({}, children)
        // } else if (!Array.isArray(children)) {
        //   throw Error(`Element [${name}]:Children must be type of Array!`)
        // }
        _element = elementFactory[name](options, _children, c);
      } else {
        throw Error(`Unknown tag name [${name}] !`)
      }
      return _element
    }
    const _model = model(c);
    // 挂载children
    return _model
  }

  function createLayer(ctx, options) {
    return new Layer(ctx, options)
  }

  // 注册全局组件
  function registerComponent(name, factory) {
    if (elementFactory[name]) {
      throw Error(`Already exist tag name [${name}] !`)
    }
    elementFactory[name] = factory;
  }

  const ef = {
    createLayer,
    createElement,
    component: registerComponent,
    View,
    Text,
    Image: $Image,
    Layer,
    ScrollView
  };

  return ef;

})));
