(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.easyCanvas = factory());
}(this, (function () { 'use strict';

  const DISPLAY = {
    BLOCK: 'block',
    INLINE_BLOCK: 'inline-block',
    INLINE: 'inline', // 用户不能设置inline，text默认为inline
    FLEX: 'flex',
    NONE: 'none'
  };

  const WIDTH = {
    AUTO: 'auto',
    OUTER: '100%'
  };

  const POSITION = {
    ABSOLUTE: 'absolute',
    FIXED: 'fixed',
    RELATIVE: 'relative',
    STATIC: 'static'
  };

  const TEXT_ALIGN = {
    LEFT: 'left',
    RIGHT: 'right',
    CENTER: 'center'
  };

  const FLEX_DIRECTION = {
    ROW: 'row',
    COLUMN: 'column'
  };

  const DEFAULT_STYLES = {
    display: DISPLAY.BLOCK,
    fontSize: 14,
    fontWeight: 400,
    fontFamily: "Microsoft Yahei",
    color: '#000',
    paddingTop: 0,
    paddingBottom: 0,
    paddingLeft: 0,
    paddingRight: 0,
    marginTop: 0,
    marginBottom: 0,
    marginLeft: 0,
    marginRight: 0,
    height: WIDTH.AUTO,
    borderRadius: 0,
    lineCap: 'square',
    flexDirection: FLEX_DIRECTION.ROW,
    verticalAlign: 'top',
    textAlign:'left',
    justifyContent: 'flex-start',
    alignItems: 'flex-start',
    whiteSpace: 'normal',
    zIndex: 1
  };

  var STYLES = {
    DISPLAY,
    WIDTH,
    POSITION,
    DEFAULT_STYLES,
    TEXT_ALIGN,
    FLEX_DIRECTION
  };

  function isExact(num) {
    return typeof num === 'number'
  }

  function isAuto(num) {
    return num === 'auto'
  }

  function isOuter(num) {
    if (typeof num !== 'string') return
    return num.match('%')
  }

  function parseOuter(num) {
    let _n = parseInt(num.replace('%', ''));
    return (isNaN(_n) || _n < 0) ? 0 : (_n / 100)
  }


  function walk(element, callback) {
    callback(element);
    if (element.hasChildren()) {
      element._getChildren().forEach(child => {
        walk(child, callback);
      });
    }
  }


  function isWX() {
    return !window
  }

  function isEndNode(el) {
    return el.parent && !el.next && !el.hasChildren()
  }

  class Line {
      constructor(){
          this.width = 0;
          this.height = 0;
          this.right = 0; // 右边界
          this.y = 0; // 上
          this.doorClosed = false; // 是否允许加入
          this.outerWidth = 0;
          this.container = null;
          this.elements = [];
          this.start = null; // 起点，行最左边第一个
          this.end = null; // 结束
      }

      bind(el){
          this.container = el.parent;
          this.height = el.parent && el.parent.renderStyles.lineHeight || 0;
          this.outerWidth = el.parent && isAuto(el.parent.styles.width) ?Infinity: el.parent.renderStyles.contentWidth;
          this.right = el._getContainerLayout().contentX;
          this.y = this.getPreLineBottom(el);
          this.start = el;
          this.add(el);
      }

      add(el){
          this.elements.push(el);
          el.line = this;
          this.refreshWidthHeight(el);
      }

      refreshWidthHeight(el){
          if(el.renderStyles.height>this.height){
              this.height = el.renderStyles.height;
          }

          // 刷新位置，首先以左边计算
          el.x = this.right;
          el.y = this.y + (this.height - el.renderStyles.contentHeight)/2;

          this.width += el.renderStyles.width;
          this.right += el.renderStyles.width;
      }

      canIEnter(el){
          if((el.renderStyles.width + this.width) >this.outerWidth){
              // new line
              this.end = this.elements[this.elements.length-1];
              this.refreshXAlign();
              return false
          }else {
              return true
          }
      }

      getPreLineBottom(el){
          if(el.pre){
              if(el.pre.line){
                  return el.pre.line.height + el.pre.line.y
              }else {
                  return el._getPreLayout().y + el._getPreLayout().height
              }
          }else {
              return el._getContainerLayout().contentY
          }
      }

      refreshXAlign(){
          if(this.outerWidth > 5000) return
          if(!this.end.parent) return
          let offsetX = this.outerWidth - this.end.x-this.end.renderStyles.width;
          if(this.end.parent.textAlign === 'center'){
              offsetX = offsetX/2;
          }else if(this.end.parent.textAlign === 'left'){
              offsetX = 0;
          }
          this.elements.forEach(child => {
              child.x += offsetX;
              child.contenX += offsetX;
          });
      }
  }

  /**
   * Element类实现盒模型以及定位，不具备绘制
   * 其他类继承实现
   *
   */




  class Element {
    constructor(options, children) {
      this.options = Object.assign({ attrs: {}, styles: {}, on: {} }, options);
      this.children = children;
      this.styles = null;
      this.parent = null;
      this.renderStyles = null;
      this.x = 0;
      this.y = 0;
      this.pre = null;
      this.next = null;
      this.render = null;
      this.root = null;
      this.container = null;
      // this.init()
    }

    init() {
      this._initStyles();
      this.initEvent();
    }

    initEvent() {
      const { click } = this.options.on;
      if (click) {
        const { click } = this.options.on;
        this.getLayer().eventManager.onClick(click, this);
      }
    }

    removeEvent() {
      this.getLayer().eventManager.removeElement(this);
    }

    getLayer() {
      return this.root.layer
    }

    mount(layer) {
      layer.mountNode(this);
    }

    _restore(callback) {
      this.getCtx().save();
      callback();
      this.getCtx().restore();
    }

    _path(callback) {
      this.getCtx().beginPath();
      callback();
      this.getCtx().closePath();
    }

    _initStyles() {
      this.styles = Object.assign({}, this._getDefaultStyles(), this._getParentStyles(), this.options.styles || {});

      this._completeStyles();

      this._initRenderStyles();
    }

    _initRenderStyles(){
      const renderStyles = { ...this.styles };
      const parentWidth = this._getContainerLayout().contentWidth;
      const parentHeight = this._getContainerLayout().contentHeight;

      if(isAuto(renderStyles.width)){
        renderStyles.width = 0;
      }else if(isOuter(renderStyles.width)){
        renderStyles.width = parseOuter(renderStyles.width) * parentWidth;
      }

      if(isAuto(renderStyles.height)){
        renderStyles.height = 0;
      }else if(isOuter(renderStyles.height)){
        renderStyles.height = parseOuter(renderStyles.height) * parentHeight;
      }

   

      if(!renderStyles.width) renderStyles.width = 0;
      if(!renderStyles.height) renderStyles.height = 0;


      // 初始化contentWidth 
      renderStyles.contentWidth = renderStyles.width - renderStyles.paddingLeft - renderStyles.paddingRight - renderStyles.marginLeft - renderStyles.marginRight - renderStyles.borderWidth;
      renderStyles.contentHeight = renderStyles.height - renderStyles.paddingTop - renderStyles.paddingBottom - renderStyles.marginTop - renderStyles.marginBottom - renderStyles.borderWidth;
      this.renderStyles = renderStyles;
    }

    /**
     * 需要继承的styles放在这里
     */
    _getParentStyles() {
      let { textAlign, lineHeight, fontSize, color, fontFamily, alignItems } = this.parent && this.parent.styles || {};
      let extendStyles = {};
      // if (textAlign) extendStyles.textAlign = textAlign
      if (lineHeight) extendStyles.lineHeight = lineHeight;
      if (fontSize) extendStyles.fontSize = fontSize;
      if (color) extendStyles.color = color;
      if (fontFamily) extendStyles.fontFamily = fontFamily;
      return extendStyles
    }

    _completeStyles() {
      this._completeFlex();

      this._completeWidth();

      this._completeBorder();

      this._completeFont();

    }

    /**
     * borderwidth到各个边
     */
    _completeBorder() {
      let { borderWidth, borderLeftWidth, borderRightWidth, borderBottomWidth, borderTopWidth, borderRadius } = this.styles;
      if (!borderWidth) {
        this.styles.borderWidth = 0;
        borderWidth = 0;
      }
      if (Array.isArray(borderWidth)) {
        this.styles.borderTopWidth = borderWidth[0];
        this.styles.borderRightWidth = borderWidth[1];
        this.styles.borderBottomWidth = borderWidth[2];
        this.styles.borderLeftWidth = borderWidth[3];
      } else {
        if (!borderLeftWidth) {
          this.styles.borderLeftWidth = borderWidth;
        }
        if (!borderRightWidth) {
          this.styles.borderRightWidth = borderWidth;
        }
        if (!borderBottomWidth) {
          this.styles.borderBottomWidth = borderWidth;
        }
        if (!borderTopWidth) {
          this.styles.borderTopWidth = borderWidth;
        }
      }
      if (borderRadius) {
        this.styles.overflow = 'hidden';
      }
    }

    _completeWidth() {
      if (!this.styles.width) {
        if (this.styles.display === STYLES.DISPLAY.INLINE_BLOCK || this.styles.display === STYLES.DISPLAY.INLINE || !this.isInFlow()) {
          this.styles.width = STYLES.WIDTH.AUTO;
        } else if (this.styles.display === STYLES.DISPLAY.BLOCK || this.styles.display === STYLES.DISPLAY.FLEX) {
          this.styles.width = STYLES.WIDTH.OUTER;
        } else {
          this.styles.width = 0;
        }
      }
    }

    _completeFont() {
      if (this.styles.fontSize && !this.styles.lineHeight) {
        this.styles.lineHeight = this.styles.fontSize * 1.4;
      } else if (!this.styles.lineHeight) {
        this.styles.lineHeight = 14;
      }
    }

    _completeFlex() {
      if (this.parent && this.parent.styles.display === STYLES.DISPLAY.FLEX) {
        // flex布局内 width 和flex需要有一个
        if (!this.styles.width && !this.styles.flex) {
          this.styles.flex = 1;
        }
      }
    }

    _getDefaultStyles() {
      return STYLES.DEFAULT_STYLES
    }

    hasChildren() {
      return Array.isArray(this.children) && this.children.length ? true : false
    }

    _getChildren() {
      return this.hasChildren() ? this.children : []
    }

    // 获取文档流中的子节点
    _getChildrenInFlow() {
      return this._getChildren().filter(item => item.isInFlow())
    }

    // 是否在文档流中
    isInFlow() {
      const { position, display } = this.styles;
      return position !== STYLES.POSITION.ABSOLUTE && position !== STYLES.POSITION.FIXED
    }

    _setParent(element) {
      this.parent = element;
      this.root = element.root;
    }

    _setSibling(pre, next) {
      this.pre = pre;
      this.next = next;
    }

    _generateRender() {
      return this
    }

    getCtx() {
      return this.root.layer.ctx
    }

    /**
     * 实现文档流 需要知道上一个兄弟节点
     */
    _reflow() {
      

    }

    // paint队列执行
    _repaint() {
      this.getCtx().save();

      this._drawBox();

      this._drawBackground();

      this._drawContent();

    }

    // 栈
    _afterPaint() {
      // 这里通过this.ctx栈实现了overflow
      // 第一步判断没有子元素，绘制完成即restore 有子元素需要子元素全部绘制完毕再restore
      if (!this.hasChildren()) {
        this.getCtx().restore();
      }

      // 如果到了层级的最后一个 释放父级的stack
      if (isEndNode(this)) {
        // 首先释放第一层父级
        this.getCtx().restore();
        let cur = this.parent;
        while (cur && !cur.next) {
          // 如果父级也是同级最后一个，再闭合上一个
          this.getCtx().restore();
          cur = cur.parent;
        }
      }
    }

    _drawBox() {
      
    }

    _drawContent() {

    }

    _drawBackground() {

    }

    _initWidthHeight(){
      const { width, height, display, flex, marginLeft, marginRight, marginTop, marginBottom } = this.styles;
      const layout = this._measureLayout();
      // 初始化宽度高度
      if (isAuto(width)) {
        this.renderStyles.contentWidth = layout.width;
      } 

      if (isAuto(height)) {
        // 不填就是auto
        this.renderStyles.contentHeight = layout.height;
      }

      this._refreshLayoutWithContent();

      // if(display === STYLES.DISPLAY.INLINE_BLOCK){
      //   // 如果是inline-block
      //   this._bindLine()
      // }
    }

    _initPosition(){
      const { contentX, contentY, contentWidth, contentHeight } = this._getContainerLayout();
      const {paddingLeft,paddingTop,borderWidth,marginLeft,marginTop} = this.renderStyles;
      // 初始化ctx位置
      if (!this.isInFlow()) {
        // 不在文档流中
        const { top, bottom, right, left, width, height } = this.renderStyles;
        if (isExact(top)) {
          this.y = contentY + top;
        } else if (isExact(bottom)) {
          this.y = contentY + contentHeight - bottom - height;
        }

        if (isExact(left)) {
          this.x = contentX + left;
        } else if (isExact(right)) {
          this.x = contentX + contentWidth - right - width;
        }
      }else if(this._InFlexBox());else if(this.renderStyles.display === STYLES.DISPLAY.INLINE_BLOCK){
        // inline-block到line里计算
        this._bindLine();
      }else {
        this.x = contentX;
        this.y = this._getPreLayout().y + this._getPreLayout().height;
      }
      this.contentX = this.x+paddingLeft+borderWidth+marginLeft;
      this.contentY = this.y+paddingTop+borderWidth+marginTop;
    }

    _InFlexBox(){
      if(!this.parent) return false
      if(this.parent && this.parent.renderStyles.display === STYLES.DISPLAY.FLEX) return true
    }


    // 父元素根据子元素撑开content后，再计算width
    _refreshLayoutWithContent() {
      this.renderStyles.height = this.renderStyles.contentHeight + this.renderStyles.paddingTop + this.renderStyles.paddingBottom + this.renderStyles.marginTop + this.renderStyles.marginBottom + this.renderStyles.borderWidth;
      this.renderStyles.width = this.renderStyles.contentWidth + this.renderStyles.paddingLeft + this.renderStyles.paddingRight + this.renderStyles.marginLeft + this.renderStyles.marginRight + this.renderStyles.borderWidth;
    }

    _bindLine(){
      if(this.pre && this.pre.line && this.pre.line.canIEnter(this)){
        this.pre.line.add(this);
      }else {
        // 新行
        new Line().bind(this);
      }
    }

    /**
     * 计算子元素高度，撑开父元素
     */
    _calcContentHeightWidthChildren() {
      // todo 没有考虑inline-block
      let complete = true;
      let lineHeight = 0;
      const heightArr = [];
      this._getChildrenInFlow().forEach(child => {
        // 如果还有没计算完成的，这里可以去掉了，全面通过是否有下一个元素判断好了
        if (!typeof child.renderStyles.height === 'number') {
          complete = false;
        }
        // 如果是第一个元素需要纳入计算
        if (child._needNewLine()) {
          // 从一行到下一个新一行
          heightArr.push(lineHeight);
          lineHeight = child.renderStyles.height;

        } else {
          // 如果是同一行，取最大的
          if (child.renderStyles.height > lineHeight) {
            lineHeight = child.renderStyles.height;
          }
        }

        if (!child.next) {
          // 如果没有下一个了
          heightArr.push(lineHeight);
          lineHeight = 0;
        }
      });

      return complete ? heightArr.reduce((sum, val) => sum + (val >= 0 ? val : 0)) : this.renderStyles.height

    }

    /**
     * 是否需要新起一行
     */
    _needNewLine() {
      const { display } = this.renderStyles;
      const { whiteSpace } = this.parent && this.parent.renderStyles || {};
      if (!this.pre) return true
      // flex容器内
      if (this.parent && this.parent.renderStyles.display === STYLES.DISPLAY.FLEX && this.pre && this.parent.renderStyles.flexDirection === STYLES.FLEX_DIRECTION.ROW) {
        return false
      }

      // block等
      if (display === STYLES.DISPLAY.BLOCK || display === STYLES.DISPLAY.FLEX) {
        return true
      }

      // 到这里都是inline-block或者inline了
      if (whiteSpace === 'nowrap') return false
      if (this.pre) {
        let { width } = this.renderStyles;
        if (width === STYLES.WIDTH.AUTO) width = 0;
        const { display, width: preWidth } = this.pre.renderStyles;
        const { width: containerWidth, x: containerX } = this._getContainerLayout();
        if (display === STYLES.DISPLAY.BLOCK || display === STYLES.DISPLAY.FLEX) {
          return true
        } else if ((preWidth + this.pre.x + width) > (containerX + containerWidth)) {
          // 这里将当前宽度等于上一个的宽度了 因为这里宽度还是0，暂时还没有好的解决方案
          // 如果inlineblock顶到右边，换行
          return true
        }

      }

      return false

    }

    _getContainerLayout() {
      let container = this.parent;
      if (this.styles.position === STYLES.POSITION.STATIC) ;
      if (!container) {
        // root
        container = {
          renderStyles: {
            width: this.container.width,
            height: this.container.height,
            paddingTop: 0,
            paddingBottom: 0,
            paddingLeft: 0,
            paddingRight: 0,
            marginLeft: 0,
            marginRight: 0,
            marginTop: 0,
            marginBottom: 0,
            contentWidth: this.container.width,
            contentHeight: this.container.height
          },
          x: 0,
          y: 0,
          contentX: 0,
          contentY: 0
        };
      }
      return {
        width: container.renderStyles.width,
        height: container.renderStyles.height,
        x: container.x,
        y: container.y,
        paddingTop: container.renderStyles.paddingTop,
        paddingBottom: container.renderStyles.paddingBottom,
        paddingLeft: container.renderStyles.paddingLeft,
        paddingRight: container.renderStyles.paddingRight,
        marginLeft: container.renderStyles.marginLeft,
        marginRight: container.renderStyles.marginRight,
        marginTop: container.renderStyles.marginTop,
        marginBottom: container.renderStyles.marginBottom,
        contentX: container.contentX,
        contentY: container.contentY,
        contentWidth: container.renderStyles.contentWidth,
        contentHeight: container.renderStyles.contentHeight
      }
    }

    // 这里前一个节点必须在文档流中
    _getPreLayout() {
      let cur = this.pre;
      while (cur && !cur.isInFlow()) {
        cur = cur.pre;
      }
      // 如果没有前一个或者前面的都不在文档流中，获取容器的
      if (cur) {
        return {
          width: cur.renderStyles.width,
          height: cur.renderStyles.height,
          x: cur.x,
          y: cur.y
        }
      } else {
        return {
          width: 0,
          height: 0,
          x: this._getContainerLayout().contentX,
          y: this._getContainerLayout().contentY
        }
      }
    }

    // 计算自身的高度
    _measureLayout() {
      let width = 0; // 需要考虑原本的宽度
      let height = 0;
      this._getChildrenInFlow().forEach(child => {
        if(child.renderStyles.width>width){
          width = child.renderStyles.width;
        }
        height += child.renderStyles.height;
      });

      return { width, height}
    }

    _px(num) {
      // if (num && isExact(num)) {
      //   return num / this.root.container.dpr
      // }
      return num
    }

    // 原理 统一从左边往右移动 必须在正常排列完成后再次进行
    _patchInlineBlockAlign() {
      const { textAlign, contentWidth, lineHeight } = this.renderStyles;
      const children = this._getChildrenInFlow();
      if (!children.length || children[0].renderStyles.display !== 'inline-block') return
      let rightOffset = 0;
      let curLineHeight = 0;
      const translateX = (element) => {
        let offsetY = 0;
        if (element.renderStyles.verticalAlign === 'bottom') {
          offsetY = curLineHeight - element.renderStyles.height;
        } else if (element.renderStyles.verticalAlign === 'middle') {
          offsetY = (curLineHeight - element.renderStyles.height) / 2;
        } else {
          offsetY = 0;
        }
        walk(element, (child) => {
          if (child.isInFlow()) {
            child.x += rightOffset;
            child.contentX += rightOffset;
            child.y += offsetY;
            child.contentY += offsetY;
          }
        });

      };
      const refreshX = (element) => {
        curLineHeight = getLineHeight(element);
        rightOffset = this.contentX + contentWidth - (element.x + element.renderStyles.width);
        if (textAlign === 'center') rightOffset = rightOffset / 2;
        if (textAlign === 'left' || !textAlign) rightOffset = 0;
      };
      let cur = null;
      for (let i = children.length - 1; i >= 0; i--) {
        cur = children[i];
        if (!cur.next) {
          // 最后一个 只有一个也会走这里
          refreshX(cur);
          translateX(cur);
        } else if (!cur.pre) {
          // 第一个
          translateX(cur);
        } else if (cur.next._needNewLine()) {
          refreshX(cur);
          translateX(cur);
        } else {
          translateX(cur);
        }
      }
    }

    _patchFlex() {
      const children = this._getChildrenInFlow();
      const { contentHeight, contentWidth, alignItems, justifyContent } = this.renderStyles;
      if (this.renderStyles.display !== 'flex' || !children.length) return
      let offsetX = 0;
      let offsetY = 0;
      if (justifyContent === 'flex-end') {
        offsetX = (this.contentX + contentWidth) - (children[children.length - 1].renderStyles.width + children[children.length - 1].x);
      } else if (justifyContent === 'center') {
        offsetX = ((this.contentX + contentWidth) - (children[children.length - 1].renderStyles.width + children[children.length - 1].x)) / 2;
      }
      for (let i = children.length - 1; i >= 0; i--) {
        if (alignItems === 'flex-end') {
          offsetY = contentHeight - children[i].renderStyles.height;
        } else if (alignItems === 'center') {
          offsetY = (contentHeight - children[i].renderStyles.height) / 2;
        } else {
          offsetY = 0;
        }
        walk(children[i], (el) => {
          el.y += offsetY;
          el.contentY += offsetY;
          el.x += offsetX;
          el.contentX += offsetX;
        });
      }
    }

    // 获取元素，只会找该元素子级
    getElementBy(key, value) {
      let match = [];
      walk(this, (element) => {
        if (element.options.attrs[key] === value) {
          match.push(element);
        }
      });
      return match
    }

    // 添加在最后
    appendChild(element) {
      if (!element instanceof Element) throw Error('Unknown Element type')
      this.children.push(element);
      this._connectChildren();
      this.getLayer().initNode(element);
      this.getLayer().flow();
      this.getLayer().repaint();
      return element
    }

    //
    prependChild(element) {
      if (!element instanceof Element) throw Error('Unknown Element type')
      this.children.unshift(element);
      this._connectChildren();
      this.getLayer().initNode(element);
      this.getLayer().flow();
      this.getLayer().repaint();
      return element
    }

    removeChild(element) {
      if (!element instanceof Element) throw Error('Unknown Element type')
      const index = this._getChildren().indexOf(element);
      if (index < 0) throw Error('Element must be the child of parent')
      const pre = this._getChildren()[index - 1];
      const next = this._getChildren()[index + 1];
      if (pre) {
        pre._setSibling(pre.pre, next);
      }
      if (next) {
        next._setSibling(pre, next.next);
      }
      this.children.splice(index, 1);
      element.removeEvent();
      this.getLayer().reflow();
      this.getLayer().repaint();
    }

    append(element) {
      if (!element instanceof Element) throw Error('Unknown Element type')
      if (!this.parent) throw Error('Can not add element to root level!')
      let children = [];
      this.parent.children.forEach(child => {
        children.push(child);
        if (child === this) {
          children.push(element);
        }
      });
      this.parent.children = children;
      this.parent._connectChildren();
      this.getLayer().initNode(element);
      this.getLayer().flow();
      this.getLayer().repaint();
    }

    prepend(element) {
      if (!element instanceof Element) throw Error('Unknown Element type')
      if (!this.parent) throw Error('Can not add element to root level!')
      let children = [];
      for (let i = this.parent.children.length - 1; i >= 0; i--) {
        children.unshift(this.parent.children[i]);
        if (this.parent.children[i] === this) {
          children.unshift(element);
        }
      }
      this.parent.children = children;
      this.parent._connectChildren();
      this.getLayer().initNode(element);
      this.getLayer().flow();
      this.getLayer().repaint();
    }

  }


  function getLineHeight(el) {
    if (el.renderStyles.display === 'block' || el.renderStyles.display === 'flex') return el.renderStyles.height
    // right
    let max = 0;
    let cur = el;
    while (cur && !cur._needNewLine()) {
      if (cur.renderStyles.height > max && cur.isInFlow()) {
        max = cur.renderStyles.height;
      }
      cur = cur.next;
    }
    // left
    cur = el;
    while (cur && !cur._needNewLine()) {
      if (cur.renderStyles.height > max && cur.isInFlow()) {
        max = cur.renderStyles.height;
      }
      cur = cur.pre;
    }

    // 最后肯定剩下一个头
    if (cur.renderStyles.height > max) {
      max = cur.renderStyles.height;
    }
    return max
  }

  class View extends Element {
    _getDefaultStyles() {
      return {
        ...STYLES.DEFAULT_STYLES,
        display: STYLES.DISPLAY.BLOCK
      }
    }

    _completeStyles() {
      super._completeStyles();
      this._completePaddingMargin();
    }

    _completePaddingMargin() {
      if (this.styles.padding) {
        if (isExact(this.styles.padding)) {
          this.styles.paddingLeft = this.styles.padding;
          this.styles.paddingBottom = this.styles.padding;
          this.styles.paddingRight = this.styles.padding;
          this.styles.paddingTop = this.styles.padding;
        } else if (Array.isArray(this.styles.padding)) {
          // 支持数组[10,20]相当于padding:10px 20px;
          if (this.styles.padding.length === 2) {
            this.styles.paddingLeft = this.styles.paddingRight = this.styles.padding[1];
            this.styles.paddingBottom = this.styles.paddingTop = this.styles.padding[0];
          } else if (this.styles.padding.length === 4) {
            this.styles.paddingLeft = this.styles.padding[3];
            this.styles.paddingBottom = this.styles.padding[2];
            this.styles.paddingRight = this.styles.padding[1];
            this.styles.paddingTop = this.styles.padding[0];
          }
        }
      }

      if (isExact(this.styles.margin)) {
        this.styles.marginLeft = this.styles.margin;
        this.styles.marginBottom = this.styles.margin;
        this.styles.marginRight = this.styles.margin;
        this.styles.marginTop = this.styles.margin;
      } else if (Array.isArray(this.styles.margin)) {
        // 支持数组[10,20]相当于padding:10px 20px;
        if (this.styles.margin.length === 2) {
          this.styles.marginLeft = this.styles.marginRight = this.styles.margin[1];
          this.styles.marginBottom = this.styles.marginTop = this.styles.margin[0];
        } else if (this.styles.margin.length === 4) {
          this.styles.marginLeft = this.styles.margin[3];
          this.styles.marginBottom = this.styles.margin[2];
          this.styles.marginRight = this.styles.margin[1];
          this.styles.marginTop = this.styles.margin[0];
        }
      }
    }

    _reflow() {
      super._reflow();
    }

    _repaint() {
      super._repaint();
    }

    _afterPaint() {
      super._afterPaint();
    }

    _drawBackground() {
      const { backgroundColor, contentWidth, contentHeight, paddingLeft, paddingRight, paddingTop, paddingBottom, opacity } = this.renderStyles;
      const ctx = this.getCtx();

      if (isExact(opacity)) {
        // 绘制透明图
        ctx.globalAlpha = opacity;
      }

      this._clip();
      // draw background
      if (backgroundColor) {
        this.getCtx().fillStyle = backgroundColor;
        this.getCtx().fillRect(this.contentX - paddingLeft, this.contentY - paddingTop, contentWidth + paddingLeft + paddingRight, contentHeight + paddingTop + paddingBottom);
      }
    }

    _drawBox() {

      this._drawRadiusBorder();

  // for debug
  if (this.getLayer().options && this.getLayer().options.debug) {
    this.getCtx().strokeStyle = 'green';
    this.getCtx().strokeRect(this.x, this.y, this.renderStyles.width, this.renderStyles.height);
    // ctx.strokeStyle = '#fff'
    // ctx.strokeText(`${parseInt(this.contentX)} ${parseInt(this.contentY)} ${contentWidth} ${contentHeight}`, this.contentX + 100, this.contentY + 10)

    //
  }

    }

    _drawRadiusBorder() {
      if (!(this.renderStyles.borderColor || this.renderStyles.shadowBlur)) return
      const { contentWidth, contentHeight, paddingLeft, paddingTop, borderStyle,
        paddingRight, paddingBottom, shadowBlur, shadowColor, backgroundColor, shadowOffsetX, shadowOffsetY,
        borderLeftWidth, borderRightWidth, borderTopWidth, borderBottomWidth } = this.renderStyles;

      const angle = Math.PI / 2;
      let borderRadius = this._getBorderRadius();


      // 这里是计算画border的位置，起点位置是在线条中间，所以要考虑线条宽度
      let x = this.contentX - this.renderStyles.paddingLeft - borderLeftWidth / 2;
      let y = this.contentY - this.renderStyles.paddingTop - borderTopWidth / 2;
      let w = contentWidth + paddingLeft + paddingRight + (borderLeftWidth + borderRightWidth) / 2;
      let h = contentHeight + paddingTop + paddingBottom + (borderTopWidth + borderBottomWidth) / 2;


      const topBorder = () => {
        // 左上角开始
        this.getCtx().moveTo(x, y + borderRadius);
        borderRadius && this.getCtx().arc(x + borderRadius, y + borderRadius, borderRadius, 2 * angle, 3 * angle);
        this.getCtx().lineTo(x + w - borderRadius, y);
      };
      const rightBorder = () => {
        // 右上角
        // this.getCtx().moveTo(x + w - borderRadius, y)
        borderRadius && this.getCtx().arc(x + w - borderRadius, y + borderRadius, borderRadius, 3 * angle, 4 * angle);
        this.getCtx().lineTo(x + w, y + h - borderRadius);
      };

      const bottomBorder = () => {
        // 右下角
        // this.getCtx().moveTo(x + w, y + h - borderRadius)
        borderRadius && this.getCtx().arc(x + w - borderRadius, y + h - borderRadius, borderRadius, 0, angle);
        this.getCtx().lineTo(x + borderRadius, y + h);
      };

      const leftBorder = () => {
        // 左下角
        borderRadius && this.getCtx().arc(x + borderRadius, y + h - borderRadius, borderRadius, angle, angle * 2);
        this.getCtx().lineTo(x, y + borderRadius);
      };

      this.getCtx().lineCap = this.renderStyles.lineCap;
      this.getCtx().strokeStyle = this.renderStyles.borderColor;

      // 实现虚线
      if (borderStyle && borderStyle !== 'solid') {
        if (Array.isArray(borderStyle)) {
          this.getCtx().setLineDash(borderStyle);
        } else {
          this.getCtx().setLineDash([5, 5]);
        }
      }

      const stroke = (borderWidth) => {
        // 有样式则绘制出来
        this.getCtx().lineWidth = borderWidth;
        this.getCtx().stroke();
      };
      // 绘制boxshadow
      if (shadowColor && shadowBlur) {
        this._restore(() => {
          this._path(() => {
            topBorder();
            rightBorder();
            bottomBorder();
            leftBorder();
          });
          if (isExact(shadowOffsetX)) {
            this.getCtx().shadowOffsetX = shadowOffsetX;
          }
          if (isExact(shadowOffsetY)) {
            this.getCtx().shadowOffsetY = shadowOffsetY;
          }
          this.getCtx().shadowBlur = shadowBlur;
          this.getCtx().shadowColor = shadowColor;
          this.getCtx().fillStyle = shadowColor;
          this.getCtx().fill();
        });
      }
      this._restore(() => {
        this._path(() => {

          x = this.contentX - this.renderStyles.paddingLeft - borderLeftWidth / 2;
          y = this.contentY - this.renderStyles.paddingTop - borderTopWidth / 2;
          w = contentWidth + paddingLeft + paddingRight + (borderLeftWidth + borderRightWidth) / 2;
          h = contentHeight + paddingTop + paddingBottom + (borderTopWidth + borderBottomWidth) / 2;
          if (this.renderStyles.borderTopWidth) {
            topBorder();
            stroke(this.renderStyles.borderTopWidth);
          }
          if (this.renderStyles.borderRightWidth) {
            this.getCtx().moveTo(x + w - borderRadius, y);
            rightBorder();
            stroke(this.renderStyles.borderRightWidth);
          }
          if (this.renderStyles.borderBottomWidth) {
            this.getCtx().moveTo(x + w, y + h - borderRadius);
            bottomBorder();
            stroke(this.renderStyles.borderBottomWidth);
          }
          if (this.renderStyles.borderLeftWidth) {
            this.getCtx().moveTo(x + borderRadius, y + h);
            leftBorder();
            stroke(this.renderStyles.borderLeftWidth);
          }
        });
      });






    }

    _clip() {
      if (this.renderStyles.overflow !== 'hidden') return
      const { contentWidth, contentHeight, paddingLeft, paddingTop,
        paddingRight, paddingBottom, shadowBlur, shadowColor, backgroundColor,
        borderLeftWidth, borderRightWidth, borderTopWidth, borderBottomWidth } = this.renderStyles;

      const angle = Math.PI / 2;

      let borderRadius = this._getBorderRadius();

      // 为了把border也切进去
      let x = this.contentX - this.renderStyles.paddingLeft - borderLeftWidth;
      let y = this.contentY - this.renderStyles.paddingTop - borderTopWidth;
      let w = contentWidth + paddingLeft + paddingRight + borderLeftWidth + borderRightWidth;
      let h = contentHeight + paddingTop + paddingBottom + borderTopWidth + borderBottomWidth;

      const topBorder = () => {
        // 左上角开始
        this.getCtx().moveTo(x, y + borderRadius);
        borderRadius && this.getCtx().arc(x + borderRadius, y + borderRadius, borderRadius, 2 * angle, 3 * angle);
        this.getCtx().lineTo(x + w - borderRadius, y);
      };
      const rightBorder = () => {
        // 右上角
        // this.getCtx().moveTo(x + w - borderRadius, y)
        borderRadius && this.getCtx().arc(x + w - borderRadius, y + borderRadius, borderRadius, 3 * angle, 4 * angle);
        this.getCtx().lineTo(x + w, y + h - borderRadius);
      };

      const bottomBorder = () => {
        // 右下角
        // this.getCtx().moveTo(x + w, y + h - borderRadius)
        borderRadius && this.getCtx().arc(x + w - borderRadius, y + h - borderRadius, borderRadius, 0, angle);
        this.getCtx().lineTo(x + borderRadius, y + h);
      };

      const leftBorder = () => {
        // 左下角
        borderRadius && this.getCtx().arc(x + borderRadius, y + h - borderRadius, borderRadius, angle, angle * 2);
        this.getCtx().lineTo(x, y + borderRadius);
      };

      this._path(() => {
        topBorder();
        rightBorder();
        bottomBorder();
        leftBorder();
      });


      this.getCtx().clip();

    }

    _getBorderRadius() {
      const { contentWidth, contentHeight } = this.renderStyles;
      let { borderRadius } = this.renderStyles;
      if (borderRadius * 2 > contentWidth) {
        // 如果大于一半，则角不是90度，统一限制最大为一半
        borderRadius = contentWidth / 2;
      }
      if (borderRadius * 2 > contentHeight) {
        borderRadius = contentHeight / 2;
      }
      if (borderRadius < 0) borderRadius = 0;
      return borderRadius
    }



  }

  class Text extends Element {
    constructor(options, children) {
      super(options, children);
      this._layout = null; // layout用来保存计算的自身高度
      this._lines = [];
      this.children += '';
    }

    _getDefaultStyles() {
      return {
        ...STYLES.DEFAULT_STYLES,
        display: STYLES.DISPLAY.INLINE_BLOCK,
        width: STYLES.WIDTH.AUTO,
        textAlign: 'left',
      }
    }

    _completeStyles() {
      super._completeStyles();
    }

    _completeWidth() {
      super._completeWidth();

      if (this.styles.textAlign !== 'left' && this.parent && !isAuto(this.parent.styles.width)) {
        this.styles.width = '100%';
      }
    }

    _initLayout() {
      
      super._initLayout();
    }

    _measureLayout() {
      this._restore(() => {
        this.getCtx().font = this._getFont();
        const { width } = this.getCtx().measureText(this.children);
        this._layout = { width };
        // 微信 夸克 有兼容性问题
        // this._layout.fontHeight = this._layout.actualBoundingBoxAscent || this.renderStyles.fontSize
        this._layout.fontHeight = this.renderStyles.fontSize;
        this._layout.height = this.renderStyles.lineHeight;
        this._calcLine();
      });
      return this._layout
    }

    _drawContent() {
      const { color, contentWidth, lineHeight, textAlign, textIndent } = this.renderStyles;
      let x = this.contentX;
      this.getCtx().fillStyle = color;
      this.getCtx().textAlign = textAlign;
      this.getCtx().font = this._getFont();
      if (textAlign === STYLES.TEXT_ALIGN.RIGHT) {
        x = this.contentX + contentWidth;
      } else if (textAlign === STYLES.TEXT_ALIGN.CENTER) {
        x = this.contentX + (contentWidth / 2);
      }
      let _x = x;
      this._lines.forEach((line, index) => {
        if (index === 0 && textIndent) {
          // 第一行实现textIndent
          _x = x + textIndent;
        } else {
          _x = x;
        }
        this.getCtx().fillText(line, _x, (this.contentY + this._layout.fontHeight + ((lineHeight - this._layout.fontHeight) / 2) + lineHeight * index) - 1);
      });
    }

    _getFont() {
      const { fontSize, fontWeight, fontFamily } = this.renderStyles;
      return `${fontWeight} ${fontSize}px ${fontFamily}`
    }

    _calcLine() {
      if (!this.parent || !this.children) return
      const { width: textWidth, height: textHeight } = this._layout;
      const { contentWidth: parentContentWidth } = this.parent.renderStyles;
      const { width: parentWidth } = this.parent.styles;
      // 如果一行宽度够，或者父级宽度是auto
      if ((isExact(parentContentWidth) && parentContentWidth >= textWidth) || parentWidth === STYLES.WIDTH.AUTO) {
        this._lines = [this.children];
      } else {
        this._lines = [];
        let lineIndex = 1;
        let lineText = '';
        let _layout = null;
        for (let i = 0; i < this.children.length; i++) {
          _layout = this.getCtx().measureText(lineText + this.children[i]);
          if (_layout.width > parentContentWidth) {
            if (lineIndex >= this.renderStyles.maxLine) {
              // 最大行数限制 以及maxline省略号实现
              lineText = lineText.substring(0, lineText.length - 2) + '...';
              break
            }
            // 超出了
            this._lines.push(lineText);
            lineText = '';
            lineIndex += 1;

          }

          lineText += this.children[i];
        }
        this._lines.push(lineText);
        this._layout.width = parentContentWidth;
        // 根据lineheihgt更新height
        this._layout.height = this._lines.length * this.renderStyles.lineHeight;
      }
    }
  }

  class $Image extends View {

    init() {
      super.init();
      this._imageInfo = {
        width: 0,
        height: 0,
        sx:0,
        sy:0,
        swidth:0,
        sheight:0,
        dx:0,
        dy:0,
        dwidth:0,
        dheight:0
      };
      this._image = null;
      this._loadImage();
    }

    _loadImage() {
      return new Promise((resolve, reject) => {
        loadImage(this.options.attrs.src, this.getLayer().getCanvas())
          .then(({ info, image }) => {
            this._imageInfo = info;
            this._image = image;
            resolve();

            this._layoutImage();

            // // 重新布局绘制
            // this.getLayer().reflow()
            // this.getLayer().repaint()

            // call load callback
            if(this.options.on && this.options.on.load){
              this.options.on.load(this);
            }
          });
      })
    }

    _drawContent() {
      if (!this._image) return
      const { contentWidth, contentHeight } = this.renderStyles;
      const {mode} = this.options.attrs;
      const {sx,sy,swidth,sheight,dx,dy,dwidth,dheight,width:imageW,height:imageH} = this._imageInfo;
      if(mode === 'aspectFill'){
        this.getCtx().drawImage(this._image,sx,sy,swidth,sheight, this.contentX, this.contentY, contentWidth, contentHeight);
      }else if(mode === 'aspectFit'){
        this.getCtx().drawImage(this._image,0,0,imageW,imageH,dx,dy,dwidth,dheight);
      }else {
        this.getCtx().drawImage(this._image, this.contentX, this.contentY, contentWidth, contentHeight);
      }
    }

    // 计算图片布局
    _layoutImage() {
      const { contentWidth, contentHeight } = this.renderStyles;
      const {mode} = this.options.attrs;
      const { width, height } = this.styles;
      const {width:imageW,height:imageH} = this._imageInfo;
      // 根据用户设置判断图片宽高，目前支持widthfix、heightfix、平铺
      let w = contentWidth;
      let h = contentHeight;
      if (!isAuto(width) && isAuto(height)) {
        // width fix
        w = contentWidth;
        h = getHeightByWidth(w, imageW, imageH);
      } else if (!isAuto(height) && isAuto(width)) {
        // height fix
        h = contentHeight;
        w = getWidthByHeight(h, imageW, imageH);
      } else if (isAuto(width) && isAuto(height)) {
        // auto
        w = imageW;
        h = imageH;
      }else if(mode === 'aspectFill'){
        // 填充
        if((w/h) > (imageW/imageH)){
          this._imageInfo.swidth = imageW;
          this._imageInfo.sheight = getHeightByWidth(imageW,w,h);
          this._imageInfo.sx = 0;
          this._imageInfo.sy = (imageH - this._imageInfo.sheight)/2;
        }else {
          this._imageInfo.sheight = imageH;
          this._imageInfo.swidth = getWidthByHeight(imageH,contentWidth,contentHeight);
          this._imageInfo.sy = 0;
          this._imageInfo.sx = (imageW - this._imageInfo.swidth)/2;
        }
      }else if(mode === 'aspectFit'){
        if((w/h) > (imageW/imageH)){
          this._imageInfo.dwidth = getWidthByHeight(contentHeight,imageW,imageH);
          this._imageInfo.dheight = contentHeight;
          this._imageInfo.dy = this.contentY;
          this._imageInfo.dx = (contentWidth - this._imageInfo.dwidth)/2 + this.contentX;
        }else {
          this._imageInfo.dheight = getHeightByWidth(contentWidth,imageW,imageH);
          this._imageInfo.dwidth = contentWidth;
          this._imageInfo.dx = this.contentX;
          this._imageInfo.dy = (contentHeight - this._imageInfo.dheight)/2 + this.contentY;
        }
      }else {
        w = contentWidth;
        h = contentHeight;
      }
      this._layout = {width:w,h:height};
    }

    _measureLayout(){
      if(this._layout){
        return this._layout
      }else {
        return {
          width:this.renderStyles.width,
          height:this.renderStyles.height
        }
      }
    }

  }

  // canvas可能为空，小程序下必传
  function loadImage(src, canvas) {

    return new Promise((resolve, reject) => {
      let image = null;

      if (isWX()) {
        image = canvas.createImage();
      } else {
        image = new Image();
      }

      image.src = src;
      image.onload = function (e) {
        resolve({
          image,
          info: {
            width: e.target.width,
            height: e.target.height
          }
        });
      };

    })
  }

  function getWidthByHeight(height, originWidth, originHeight) {
    return height / originHeight * originWidth
  }

  function getHeightByWidth(width, originWidth, originHeight) {
    return width / originWidth * originHeight
  }

  class EventManager {

    constructor({ simulateClick = true }) {
      this.clickList = [];
      this.touchstartList = [];
      this.touchmoveList = [];
      this.touchendList = [];
      this.touchStartEvent = null;
      this.simulateClick = simulateClick; // 是否模拟移动端点击事件
    }

    clear() {
      this.clickList = [];
      this.touchstartList = [];
      this.touchmoveList = [];
      this.touchendList = [];
    }

    click(x, y) {
      let event = new Event({ x, y, type: 'click' });
      this._emit(event);
    }

    touchstart(x, y) {
      let event = new Event({ x, y, type: 'touchstart' });
      this.touchStartEvent = event;
      this._emit(event);
    }

    touchmove(x, y) {
      let event = new Event({ x, y, type: 'touchmove' });
      this._emit(event);
    }

    touchend(x, y) {
      let event = new Event({ x, y, type: 'touchend' });
      this._emit(event);
      this.checkClick(event);
    }

    _emit(e) {
      let callbackList = [];
      switch (e.type) {
        case 'click': callbackList = this.clickList; break
        case 'touchstart': callbackList = this.touchstartList; break
        case 'touchmove': callbackList = this.touchmoveList; break
        case 'touchend': callbackList = this.touchendList; break
      }

      // let emitList = []

      // for(let i = callbackList.length-1; i>=0; i--){
      //   if(this.isPointInElement())
      // }

      for (let i = 0; i < callbackList.length; i++) {
        if (this.isPointInElement(e.x, e.y, callbackList[i].element)) {
          if (!e.currentTarget) e.currentTarget = callbackList[i].element;
          callbackList[i].callback(e);
          if (e.cancelBubble) break
        }
      }
    }

    // 待优化
    isPointInElement(x, y, element) {
      let { width, height } = element.renderStyles;
      let _x = x; // 根据scroll-view做转换
      let _y = y;
      let cur = element.parent;
      // 这里实现有点拉跨，每次都会向上遍历看有没有scroll-view
      while (cur) {
        if (cur.type === 'scroll-view' && this._isPointTouchElement(_x,_y,cur)) {
          if (cur.styles.direction === 'x') {
            _x -= cur.currentScroll;
          } else {
            _y -= cur.currentScroll;
          }
        }
        cur = cur.parent;
      }

      return this._isPointTouchElement(_x,_y,element)
    }

    _isPointTouchElement(x,y,element){
      if (x >= element.x && y >= element.y && (x <= element.x + element.renderStyles.width) && (y <= element.y + element.renderStyles.height)) {
        return true
      }
      return false
    }

    createEvent(x, y, type) {

    }

    removeElement(element) {
      this.clickList = this.clickList.filter(item => item.element !== element);
      this.touchstartList = this.touchstartList.filter(item => item.element !== element);
      this.touchmoveList = this.touchmoveList.filter(item => item.element !== element);
      this.touchendList = this.touchendList.filter(item => item.element !== element);
    }

    onClick(callback, element) {
      // 为啥要unshift呢，因为元素是从父级,往子集初始化的
      this.clickList.unshift({ callback, element });
    }

    onTouchStart(callback, element) {
      this.touchstartList.unshift({ callback, element });
    }

    onTouchMove(callback, element) {
      this.touchmoveList.unshift({ callback, element });
    }

    onTouchEnd(callback, element) {
      this.touchendList.unshift({ callback, element });
    }

    // 这里利用touchstart和touchend实现了移动端click事件
    checkClick(event) {
      if (this.touchStartEvent && this.simulateClick) {
        // 判断两点距离
        let { x: startx, y: starty } = this.touchStartEvent;
        let { x: endx, y: endy } = event;
        let distance = ((endy * endy + endx * endx) - (starty * starty + startx * startx));
        if (distance < 10 && distance > -10) {
          this.click(endx, endy);
        }
      }
    }
  }

  class Event {
    constructor({ x, y, type }) {
      this.x = x;
      this.y = y;
      this.scrollX = x; // scroll到每一层scrollview会不断变化
      this.scrollY = y;
      this.type = type;
      this.cancelBubble = false;
      this.currentTarget = null; // 第一个element
    }

    // 阻止冒泡
    stopPropagation() {
      this.cancelBubble = true;
    }
  }

  class Layer {
    constructor(ctx, options) {
      this.ctx = ctx;
      this.node = null;
      this.nodeList = [];
      this.renderList = [];
      this.options = options;
      this.eventManager = new EventManager(options);
    }

    update(ctx, options) {
      this.ctx = ctx;
      this.options = options;
      this.node.container = this.options;
    }

    mountNode(node) {
      this.node = node;
      this.node.root = this.node;
      this.node.layer = this;
      this.node.container = this.options;
      // 事件也清空一下，重新挂载
      this.eventManager.clear();
      this.initRender();
    }

    initRender() {
      this.nodeList = [];
      connectChildren(this.node,(el) => {
        this.nodeList.push(el);
      });
      // this.initPaintList()

      this.initNode();


      this.flow();

      // inline-block等还需要再重新排一次，待优化
      // this.reflow()

      this.repaint();

    }

    initNode(node = this.node) {
      walk(node, item => {
        item.init();
      });
    }

    flow(node = this.node) {
      this.reflow();
    }

    initPaintList() {
      // 这里实现index
      this.renderList = this.nodeList;
    }

    reflow(node = this.node) {
      for(let i = this.nodeList.length - 1; i>=0; i--){
        this.nodeList[i]._initWidthHeight();
      }

      for(let i = 0; i<this.nodeList.length; i++){
        this.nodeList[i]._initPosition();
      }
    }

    /**
     * 可以给定element，则只会重绘element所在的区域
     * @param {Element} element
     */
    repaint(element = this.node) {
      // let width = element.renderStyles.width
      // let height = element.renderStyles.height
      // let x = element.x
      // let y = element.y
      // this.ctx.clearRect(x, y, width, height)
      // walk(element, (item) => {
      //   item._repaint()
      //   item._afterPaint()
      // })

      // this.ctx.clearRect(this.container.x, this.node.y, this.node.renderStyles.width, this.node.renderStyles.height)
      this.ctx.clearRect(0, 0, this.options.width, this.options.height);
      walk(this.node, element => {
        element._repaint();
        element._afterPaint();
      });
      // 兼容小程序
      this.ctx.draw && this.ctx.draw();
    }

    // 小程序需要
    getCanvas() {
      return this.options && this.options.canvas
    }

  }


  function connectChildren(el,callback) {
    callback(el);
    if (el.hasChildren()) {
      const childrenRender = el._getChildren().map((child, index) => {
        // 设置parent
        child._setParent(el);
        // 设置了上一个兄弟节点
        child._setSibling(el._getChildren()[index - 1], el._getChildren()[index + 1]);
        return connectChildren(child,callback)
      }).reduce((sum, val) => [...sum, ...val]);
      return [el._generateRender(), ...childrenRender]
    } else {
      return [el._generateRender()]
    }
  }

  class ScrollView extends View {

    constructor(options, children) {
      super(options, children);
      // 外面包裹一层容器，内层的滚动
      options.styles.overflow = 'hidden';
      this.type = 'scroll-view';
      this._scrollView = new View(options, [this]);
      this._scrollView.type = 'scroll-view-container';
      return this._scrollView
    }

    _getDefaultStyles() {
      return {
        ...STYLES.DEFAULT_STYLES,
        direction: 'y',
      }
    }

    init() {
      super.init();
      this.addEventListener();

      const { height, width, direction } = this.styles;
      if (direction === 'y') {
        if (!isAuto(height)) {
          this.styles.height = 'auto';
          this.renderStyles.height = 'auto';
        } else {
          // 必须设置
          console.error('scroll-view 必须设置明确的高度');
        }
      } else if (direction === 'x') {
        if (!isAuto(width)) {
          this.styles.width = 'auto';
          this.renderStyles.width = 'auto';
        } else {
          // 必须设置
          console.error('scroll-view 必须设置明确的宽度');
        }
      }
    }

    addEventListener() {
      // 监听滚动
      this.currentScroll = 0;
      let direction = this.styles.direction;
      let start = 0;
      let lastStart = 0;
      let startMove = false;
      let offset = 0;
      let speed = 0;
      let glideInterval = null;
      let resistance = 1;

      // this.getLayer().eventManager.captureTouch(e => {
      //   if(direction === 'y'){
      //     e.scrollY -= this.currentScroll
      //   }else{
      //     e.scrollX -= this.currentScroll
      //   }
      // },this._scrollView)

      this.getLayer().eventManager.onTouchStart((e) => {
        e.stopPropagation();
        start = e[direction];
        lastStart = start;
        startMove = true;
        clearInterval(glideInterval);
      }, this._scrollView);
      this.getLayer().eventManager.onTouchMove((e) => {
        if (startMove) {
          e.stopPropagation();
          offset = (e[direction] - start);
          if (this.scrollBy(offset)) {
            lastStart = start;
            start = e[direction];
          }
        }
      }, this._scrollView);
      this.getLayer().eventManager.onTouchEnd((e) => {
        if (startMove) {
          startMove = false;
          speed = (e[direction] - lastStart) * 2;
          resistance = -speed * 0.02;
          clearInterval(glideInterval);
          glideInterval = setInterval(() => {
            if (!this.scrollBy(speed)) {
              clearInterval(glideInterval);
            }
            speed += resistance;
            if (speed * speed <= 0.05) {
              speed = 0;
              clearInterval(glideInterval);
            }
          }, 18);
        }
      }, this._scrollView);
    }

    _repaint() {
      // 滚动实现 目前是计算一次重新绘制一次，有需要再优化
      const { direction } = this.renderStyles;
      if (direction === 'y') {
        this.getCtx().translate(0, this.currentScroll);
      } else {
        this.getCtx().translate(this.currentScroll, 0);
      }
      super._repaint();
    }

    calcScrollBound(offset) {
      const { contentWidth: offsetWidth, contentHeight: offsetHeight } = this._scrollView.renderStyles;
      const { width: scrollWidth, height: scrollHeight, direction } = this.renderStyles;
      if (direction === 'y') {
        if ((offsetHeight - this.currentScroll - offset) > scrollHeight) {
          return false
        } else if (this.currentScroll + offset > 0) {
          return false
        }
      } else {
        if ((offsetWidth - this.currentScroll - offset) > scrollWidth) {
          return false
        } else if (this.currentScroll + offset > 0) {
          return false
        }
      }

      return true
    }

    scrollBy(offset) {
      if (this.calcScrollBound(offset)) {
        this.currentScroll += offset;
        this.getLayer().repaint();
        // this.getLayer().repaint(this._scrollView)
        return true
      } else {
        return false
      }
    }

    scrollTo(pos) {

    }

  }

  /**
   * 生成一个element tree
   * @param {String} name
   * @param {Function} options
   */

  const elementFactory = {};
  //
  registerComponent('view', (options, children) => new View(options, children));
  registerComponent('text', (options, children) => new Text(options, children));
  registerComponent('image', (options, children) => new $Image(options, children));
  registerComponent('scroll-view', (options, children) => new ScrollView(options, children));
  registerComponent('scrollview', (options, children) => new ScrollView(options, children));

  function createElement(model) {
    // 生成树
    function c(name, options = {}, children = []) {
      // if (arguments.length < 3) {
      //   throw Error(`Element [${name}]: need 3 argument but get 2`)
      // }
      let _element = null;
      let _children = children;
      if (elementFactory[name]) {
        // if (typeof children === 'string' && name !== 'text') {
        //   // 支持text简写
        //   _children = new Text({}, children)
        // } else if (!Array.isArray(children)) {
        //   throw Error(`Element [${name}]:Children must be type of Array!`)
        // }
        _element = elementFactory[name](options, _children, c);
      } else {
        throw Error(`Unknown tag name [${name}] !`)
      }
      return _element
    }
    const _model = model(c);
    // 挂载children
    return _model
  }

  function createLayer(ctx, options) {
    return new Layer(ctx, options)
  }

  // 注册全局组件
  function registerComponent(name, factory) {
    if (elementFactory[name]) {
      throw Error(`Already exist tag name [${name}] !`)
    }
    elementFactory[name] = factory;
  }

  const ef = {
    createLayer,
    createElement,
    component: registerComponent,
    View,
    Text,
    Image: $Image,
    Layer,
    ScrollView
  };

  return ef;

})));
