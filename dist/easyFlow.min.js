(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.easyFlow = factory());
}(this, (function () { 'use strict';

  const DISPLAY = {
    BLOCK: 'block',
    INLINE_BLOCK: 'inline-block',
    INLINE: 'inline', // 用户不能设置inline，text默认为inline
    FLEX: 'flex',
    NONE: 'none'
  };

  const WIDTH = {
    AUTO: 'auto',
    OUTER: '100%'
  };

  const POSITION = {
    ABSOLUTE: 'absolute',
    FIXED: 'fixed',
    RELATIVE: 'relative',
    STATIC: 'static'
  };

  const TEXT_ALIGN = {
    LEFT: 'left',
    RIGHT: 'right',
    CENTER: 'center'
  };

  const FLEX_DIRECTION = {
    ROW: 'row',
    COLUMN: 'column'
  };

  const DEFAULT_STYLES = {
    display: DISPLAY.BLOCK,
    fontSize: 14,
    fontWeight: 400,
    fontFamily: "Microsoft Yahei",
    color: '#000',
    paddingTop: 0,
    paddingBottom: 0,
    paddingLeft: 0,
    paddingRight: 0,
    marginTop: 0,
    marginBottom: 0,
    marginLeft: 0,
    marginRight: 0,
    height: WIDTH.AUTO,
    borderRadius: 0,
    lineCap: 'square',
    flexDirection: FLEX_DIRECTION.ROW,
    verticalAlign: 'top',
    whiteSpace: 'normal',
    zIndex: 1
  };

  var STYLES = {
    DISPLAY,
    WIDTH,
    POSITION,
    DEFAULT_STYLES,
    TEXT_ALIGN,
    FLEX_DIRECTION
  };

  function isExact(num) {
    return typeof num === 'number'
  }

  function isAuto(num) {
    return num === 'auto'
  }

  function isOuter(num) {
    if (typeof num !== 'string') return
    return num.match('%')
  }

  function parseOuter(num) {
    let _n = parseInt(num.replace('%', ''));
    return (isNaN(_n) || _n < 0) ? 0 : (_n / 100)
  }

  function walk(element, callback) {
    callback(element);
    if (element.hasChildren()) {
      element._getChildren().forEach(child => {
        walk(child, callback);
      });
    }
  }


  function isWX() {
    return !window
  }

  /**
   * inline-block block inline flex
   *
   * x
   * y
   * width
   * height
   * position
   *
   *
   */




  class Element {
    constructor(options, children) {
      this.options = options;
      this.children = children;
      this.styles = null;
      this.parent = null;
      this.renderStyles = null;
      this.x = 0;
      this.y = 0;
      this.pre = null;
      this.next = null;
      this.render = null;
      this.root = null;
      this.container = null;
      // this.init()
    }

    init() {
      this._initStyles();
      this.initEvent();
    }

    initEvent() {
      if (this.options.on) {
        const { click } = this.options.on;
        this.getLayer().eventManager.onClick(click, this);
      }
    }

    getLayer() {
      return this.root.layer
    }

    mount(layer) {
      layer.mountNode(this);
    }

    _restore(callback) {
      this.getCtx().save();
      callback();
      this.getCtx().restore();
    }

    _path(callback) {
      this.getCtx().beginPath();
      callback();
      this.getCtx().closePath();
    }

    _initStyles() {
      this.styles = Object.assign({}, this._getDefaultStyles(), this._getParentStyles(), this.options.styles || {});

      this._completeStyles();

      this.renderStyles = { ...this.styles };
    }

    /**
     * 需要继承的styles放在这里
     */
    _getParentStyles() {
      let { textAlign, lineHeight, fontSize, color, fontFamily, alignItems } = this.parent && this.parent.styles || {};
      let extendStyles = {};
      if (textAlign) extendStyles.textAlign = textAlign;
      if (lineHeight) extendStyles.lineHeight = lineHeight;
      if (fontSize) extendStyles.fontSize = fontSize;
      if (color) extendStyles.color = color;
      if (fontFamily) extendStyles.fontFamily = fontFamily;
      // 实现flex对齐
      if (alignItems === 'flex-start') extendStyles.verticalAlign = 'top';
      if (alignItems === 'center') extendStyles.verticalAlign = 'middle';
      if (alignItems === 'flex-end') extendStyles.verticalAlign = 'bottom';
      return extendStyles
    }

    _completeStyles() {
      this._completeFlex();

      this._completeWidth();

      this._completeBorder();

    }

    /**
     * borderwidth到各个边
     */
    _completeBorder() {
      let { borderWidth, borderLeftWidth, borderRightWidth, borderBottomWidth, borderTopWidth, borderRadius } = this.styles;
      if (!borderWidth) {
        this.styles.borderWidth = 0;
        borderWidth = 0;
      }
      if (!borderLeftWidth) {
        this.styles.borderLeftWidth = borderWidth;
      }
      if (!borderRightWidth) {
        this.styles.borderRightWidth = borderWidth;
      }
      if (!borderBottomWidth) {
        this.styles.borderBottomWidth = borderWidth;
      }
      if (!borderTopWidth) {
        this.styles.borderTopWidth = borderWidth;
      }
      if (borderRadius) {
        this.styles.overflow = 'hidden';
      }
    }

    _completeWidth() {
      if (!this.styles.width && !this.styles.flex) {
        if (this.styles.display === STYLES.DISPLAY.INLINE_BLOCK || this.styles.display === STYLES.DISPLAY.INLINE || !this.isInFlow()) {
          this.styles.width = STYLES.WIDTH.AUTO;
        } else if (this.styles.display === STYLES.DISPLAY.BLOCK || this.styles.display === STYLES.DISPLAY.FLEX) {
          this.styles.width = STYLES.WIDTH.OUTER;
        } else ;
      }
    }

    _completeFlex() {
      if (this.parent && this.parent.styles.display === STYLES.DISPLAY.FLEX) {
        // flex布局内 width 和flex需要有一个
        if (!this.styles.width && !this.styles.flex) {
          this.styles.flex = 1;
        }
      }
    }

    _getDefaultStyles() {
      return STYLES.DEFAULT_STYLES
    }

    /**
     * 获取入口
     */
    tree2List() {
      this.root = this;
      let list = this._connectChildren();
      return Array.isArray(list) ? list : [list]
    }


    // 遍历全部的子节点
    _connectChildren() {
      if (this.hasChildren()) {
        const childrenRender = this._getChildren().map((child, index) => {
          // 设置parent
          child._setParent(this);
          // 设置了上一个兄弟节点
          child._setSibling(this._getChildren()[index - 1], this._getChildren()[index + 1]);
          return child._connectChildren()
        }).reduce((sum, val) => [...sum, ...val]);
        return [this._generateRender(), ...childrenRender]
      } else {
        return [this._generateRender()]
      }
    }

    hasChildren() {
      return Array.isArray(this.children) && this.children.length ? true : false
    }

    _getChildren() {
      return this.hasChildren() ? this.children : []
    }

    // 获取文档流中的子节点
    _getChildrenInFlow() {
      return this._getChildren().filter(item => item.isInFlow())
    }

    // 是否在文档流中
    isInFlow() {
      const { position, display } = this.styles;
      return position !== STYLES.POSITION.ABSOLUTE && position !== STYLES.POSITION.FIXED
    }

    _setParent(element) {
      this.parent = element;
      this.root = element.root;
    }

    _setSibling(pre, next) {
      this.pre = pre;
      this.next = next;
    }

    _generateRender() {
      return this
    }

    getCtx() {
      return this.root.layer.ctx
    }

    /**
     * 实现文档流 需要知道上一个兄弟节点
     */
    _reflow() {
      // this._initClearWidthHeight()

      // 初始化尺寸 位置
      // 到这里renderstyles里的尺寸肯定是数字
      this._initStartingPoint();


      this._walkParentLayout();


      // 到这里 x ，y 肯定是数字

      this._calcContentLayout();
      this._patchAlign();

    }

    // paint队列执行
    _repaint() {
      this.getCtx().save();

      this._drawBox();

      this._drawBackground();

      this._drawContent();

    }

    // 栈
    _afterPaint() {
      // 这里通过this.ctx栈实现了overflow
      // 第一步判断没有子元素，绘制完成即restore 有子元素需要子元素全部绘制完毕再restore
      if (!this.hasChildren()) {
        this.getCtx().restore();
      }

      // 如果到了层级的最后一个 释放父级的stack
      if (this.parent && !this.next && !this.hasChildren()) {
        // 首先释放第一层父级
        this.getCtx().restore();
        let cur = this.parent;
        while (cur && !cur.next) {
          // 如果父级也是同级最后一个，再闭合上一个
          this.getCtx().restore();
          cur = cur.parent;
        }
      }
    }

    _drawBox() {

    }

    _drawContent() {

    }

    _drawBackground() {

    }

    /**
     * 初始化宽度高度 ,顺序为 父到子，前往后
     * 1、初始化明确的宽度，100% 和数字
     * 2、后面就只剩下auto需要子元素去处理
     * 3、初始化绘制的起点，包括padding margin
     */
    _initLayout() {

      this._initClearWidthHeight();
      this._calcContentLayout();

      // 到这里renderstyles里的尺寸肯定是数字

      this._walkParentLayout();

      this._initStartingPoint();

      // 到这里 x ，y 肯定是数字

      // this._initStartingPoint()

    }

    // 初始化起点
    _initStartingPoint() {
      // 初始化ctx位置
      if (!this.isInFlow()) {
        // 不在文档流中
        const { top, bottom, right, left, width, height } = this.renderStyles;
        let { contentX, contentY, contentWidth, contentHeight } = this._getContainerLayout();
        if (isExact(top)) {
          this.y = contentY + top;
        } else if (isExact(bottom)) {
          this.y = contentY + contentHeight - bottom - height;
        }

        if (isExact(left)) {
          this.x = contentX + left;
        } else if (isExact(right)) {
          this.x = contentX + contentWidth - right - width;
        }
      } else if (this._needNewLine()) {
        // 另起一行
        this.x = this._getContainerLayout().contentX;
        this.y = this._getPreLayout().y + this._getPreLayout().height;
      } else {
        this.x = this._getPreLayout().x + this._getPreLayout().width;
        this.y = this._getPreLayout().y;
      }

    }

    /**
     *
     */
    _walkParentLayout() {
      // 不是最后一个不计算,判断末梢节点
      if (this.next || this.hasChildren()) return
      // 不在文档流中不计算
      if (!this.isInFlow()) return

      let curElement = this;
      // 循环设置父级尺寸
      while (curElement.parent) {
        // 将父级宽度初始化
        // 这里应该通知父级改，先直接改了吧
        if (curElement.parent.styles.width === STYLES.WIDTH.AUTO || curElement.parent.styles.height === STYLES.WIDTH.AUTO) {
          curElement.parent._calcLayoutWithChildren();
        } else {
          // 这里应该宽度高度分开循环
          break
        }
        curElement = curElement.parent;
      }
    }

    // 将明确设置的初始化，如果是auto，先计算自身宽度，再等子元素计算
    _initClearWidthHeight() {
      const { width, height, display, flex, marginLeft, marginRight, marginTop, marginBottom } = this.styles;
      const layout = this._measureLayout();

      // 初始化宽度高度
      if (flex && this.parent && this.parent.renderStyles.display === STYLES.DISPLAY.FLEX) {
        // flex布局处理
        this.renderStyles.width = this._getFlexWidth();
      } else if (isOuter(width)) {
        // 不填默认当100% 百分比处理
        this.renderStyles.width = this._getContainerLayout().contentWidth * parseOuter(width);
      } else if (width === STYLES.WIDTH.AUTO) {
        //  自动 先计算自身
        this.renderStyles.width = layout.width;
      } else if (isExact(width)) {
        // 设置了具体的数值
        this.renderStyles.width = width + marginLeft + marginRight;
      }

      if (isOuter(height)) {
        // 不填就是auto
        this.renderStyles.height = this._getContainerLayout().contentHeight * parseOuter(height);
      } else if (height === STYLES.WIDTH.AUTO) {
        this.renderStyles.height = layout.height;
      } else if (isExact(height)) {
        this.renderStyles.height = height + marginTop + marginBottom;
      }

      // 处理borderWidth与content重叠,这里实现的是border重叠与margin的内侧
      this.renderStyles.marginTop = this.styles.borderTopWidth + this.styles.marginTop;
      this.renderStyles.marginBottom = this.styles.borderBottomWidth + this.styles.marginBottom;
      this.renderStyles.marginLeft = this.styles.borderLeftWidth + this.styles.marginLeft;
      this.renderStyles.marginRight = this.styles.borderRightWidth + this.styles.marginRight;
    }

    // 根据子元素计算宽高
    _calcLayoutWithChildren() {
      // 到这一步默认没有inline元素，因为inline元素内不允许其他element
      const { width, height } = this.styles;
      if (width === STYLES.WIDTH.AUTO) {
        this.renderStyles.contentWidth = this._calcContentWidthWidthChildren();
      }
      if (height === STYLES.WIDTH.AUTO) {
        this.renderStyles.contentHeight = this._calcContentHeightWidthChildren();
      }
      this._calcLayoutWithContent();
    }

    // 父元素根据子元素撑开content后，再计算width
    _calcLayoutWithContent() {
      this.renderStyles.height = this.renderStyles.contentHeight + this.renderStyles.paddingTop + this.renderStyles.paddingBottom + this.renderStyles.marginTop + this.renderStyles.marginBottom;
      this.renderStyles.width = this.renderStyles.contentWidth + this.renderStyles.paddingLeft + this.renderStyles.paddingRight + this.renderStyles.marginLeft + this.renderStyles.marginRight;
    }

    // 宽高计算完后，初始化content-box宽度 这里是自身初始化的，上面的是子元素触发父元素计算
    _calcContentLayout() {
      const contentLayout = getContentLayout(this);
      // if (width !== STYLES.WIDTH.AUTO) {
      this.renderStyles.contentWidth = contentLayout.contentWidth;
      // }
      // if (height !== STYLES.WIDTH.AUTO) {
      this.renderStyles.contentHeight = contentLayout.contentHeight;
      // }
      this.contentX = contentLayout.contentX;
      this.contentY = contentLayout.contentY;

      // this._pathTextAlign('right')
    }

    /**
     * 获取一行的宽度，撑开父元素
     */
    _calcContentWidthWidthChildren() {
      // 需要考虑原本的宽度
      let max = 0;
      let tempMax = max;
      this._getChildrenInFlow().forEach(child => {
        if (child._needNewLine()) {
          // 如果是新起一行，重新计算
          tempMax = 0;
        }
        tempMax += child.renderStyles.width;
        if (tempMax > max) {
          max = tempMax;
        }
      });
      return max
    }

    /**
     * 计算flex的宽度
     */
    _getFlexWidth() {
      if (!this.renderStyles.flex) return 0
      const containerContentWidth = this._getContainerLayout().contentWidth;
      let clearWidth = 0;
      let totalFlexSum = 0;
      this.parent._getChildrenInFlow().forEach(item => {
        if (isExact(item.styles.width)) {
          clearWidth += item.styles.width;
        } else if (item.renderStyles.flex) {
          totalFlexSum += item.renderStyles.flex;
        }
      });
      return (containerContentWidth - clearWidth) * (this.renderStyles.flex / totalFlexSum)
    }

    /**
     * 计算子元素高度，撑开父元素
     */
    _calcContentHeightWidthChildren() {
      // todo 没有考虑inline-block
      let complete = true;
      let lineHeight = 0;
      const heightArr = [];
      this._getChildrenInFlow().forEach(child => {
        // 如果还有没计算完成的，这里可以去掉了，全面通过是否有下一个元素判断好了
        if (!typeof child.renderStyles.height === 'number') {
          complete = false;
        }
        // 如果是第一个元素需要纳入计算
        if (child._needNewLine()) {
          // 从一行到下一个新一行
          heightArr.push(lineHeight);
          lineHeight = child.renderStyles.height;

        } else {
          // 如果是同一行，取最大的
          if (child.renderStyles.height > lineHeight) {
            lineHeight = child.renderStyles.height;
          }
        }

        if (!child.next) {
          // 如果没有下一个了
          heightArr.push(lineHeight);
          lineHeight = 0;
        }
      });

      return complete ? heightArr.reduce((sum, val) => sum + (val >= 0 ? val : 0)) : this.renderStyles.height

    }

    /**
     * 是否需要新起一行
     */
    _needNewLine() {
      const { display } = this.renderStyles;
      const { whiteSpace } = this.parent && this.parent.renderStyles || {};
      // flex容器内
      if (this.parent && this.parent.renderStyles.display === STYLES.DISPLAY.FLEX && this.pre && this.parent.renderStyles.flexDirection === STYLES.FLEX_DIRECTION.ROW) {
        return false
      }

      // block等
      if (display === STYLES.DISPLAY.BLOCK || display === STYLES.DISPLAY.FLEX) {
        return true
      }

      // 到这里都是inline-block或者inline了
      if (whiteSpace === 'nowrap') return false
      if (this.pre) {
        let { width } = this.renderStyles;
        if (width === STYLES.WIDTH.AUTO) width = 0;
        const { display, width: preWidth } = this.pre.renderStyles;
        const { width: containerWidth, x: containerX } = this._getContainerLayout();
        if (display === STYLES.DISPLAY.BLOCK || display === STYLES.DISPLAY.FLEX) {
          return true
        } else if ((preWidth + this.pre.x + width) > (containerX + containerWidth)) {
          // 这里将当前宽度等于上一个的宽度了 因为这里宽度还是0，暂时还没有好的解决方案
          // 如果inlineblock顶到右边，换行
          return true
        }

      } else {
        return true
      }

      return false

    }


    _getContainerLayout() {
      let container = this.parent;
      if (this.styles.position === STYLES.POSITION.STATIC) ;
      if (!container) {
        // root
        container = {
          renderStyles: {
            width: this.container.width,
            height: this.container.height,
            paddingTop: 0,
            paddingBottom: 0,
            paddingLeft: 0,
            paddingRight: 0,
            marginLeft: 0,
            marginRight: 0,
            marginTop: 0,
            marginBottom: 0,
            contentWidth: this.container.width,
            contentHeight: this.container.height
          },
          x: 0,
          y: 0,
          contentX: 0,
          contentY: 0
        };
      }
      return {
        width: container.renderStyles.width,
        height: container.renderStyles.height,
        x: container.x,
        y: container.y,
        paddingTop: container.renderStyles.paddingTop,
        paddingBottom: container.renderStyles.paddingBottom,
        paddingLeft: container.renderStyles.paddingLeft,
        paddingRight: container.renderStyles.paddingRight,
        marginLeft: container.renderStyles.marginLeft,
        marginRight: container.renderStyles.marginRight,
        marginTop: container.renderStyles.marginTop,
        marginBottom: container.renderStyles.marginBottom,
        contentX: container.contentX,
        contentY: container.contentY,
        contentWidth: container.renderStyles.contentWidth,
        contentHeight: container.renderStyles.contentHeight
      }
    }

    // 这里前一个节点必须在文档流中
    _getPreLayout() {
      let cur = this.pre;
      while (cur && !cur.isInFlow()) {
        cur = cur.pre;
      }
      // 如果没有前一个或者前面的都不在文档流中，获取容器的
      if (cur) {
        return {
          width: cur.renderStyles.width,
          height: cur.renderStyles.height,
          x: cur.x,
          y: cur.y
        }
      } else {
        return {
          width: 0,
          height: 0,
          x: this._getContainerLayout().contentX,
          y: this._getContainerLayout().contentY
        }
      }
    }


    // 计算自身的高度
    _measureLayout() {
      return { width: 0, height: 0, x: 0, y: 0 }
    }

    _px(num) {
      // if (num && isExact(num)) {
      //   return num / this.root.container.dpr
      // }
      return num
    }

    // 原理 统一从左边往右移动
    _patchAlign() {
      if (!this.parent) return
      if (!(this.renderStyles.display === STYLES.DISPLAY.INLINE_BLOCK || this.parent.renderStyles.display === STYLES.DISPLAY.FLEX)) return
      const textAlign = this.parent.renderStyles.textAlign;
      const verticalAlign = this.renderStyles.verticalAlign;
      let cur;
      let lastXOffset;
      let maxHeight = 0;
      const translateX = (element) => {
        element.x += lastXOffset;
        element.contentX += lastXOffset;
        // 子元素重新计算 x y位置 待优化
        element._getChildrenInFlow().forEach(child => walk(child, (el) => el.isInFlow() && el._reflow()));
      };

      const translateY = (element) => {
        let offset = 0;
        if (element.renderStyles.verticalAlign === 'middle') {
          offset = (maxHeight - element.renderStyles.height) / 2;
        } else if (element.renderStyles.verticalAlign === 'bottom') {
          offset = maxHeight - element.renderStyles.height;
        }
        element.y += offset;
        element.contentY += offset;
        // 子元素重新计算 x y位置 待优化
        element._getChildrenInFlow().forEach(child => walk(child, (el) => el.isInFlow() && el._reflow()));
      };

      const refreshXOffset = () => {

        if (textAlign === 'right') {
          lastXOffset = this._getContainerLayout().contentWidth + this._getContainerLayout().contentX - cur.x - cur.renderStyles.width;
        } else if (textAlign === 'center') {
          lastXOffset = (this._getContainerLayout().contentWidth + this._getContainerLayout().contentX - cur.x - cur.renderStyles.width) / 2;
        } else {
          lastXOffset = 0;
        }
      };

      const refreshYOffset = () => {
        if (cur.renderStyles.height <= maxHeight) return
        maxHeight = cur.renderStyles.height;
      };


      if ((this._needNewLine() || !this.next) && this.pre) {
        cur = this.pre;
        if (!this.next) {
          // 一行中的最后一个
          cur = this;
          if (this._needNewLine()) {
            refreshXOffset();
            translateX(cur);
            cur = this.pre;
          }
        }
        refreshXOffset();
        //  如果是新的一行，计算上一行的对其
        while (cur) {
          refreshYOffset();
          translateX(cur);
          cur = cur.pre;
          if (!cur) {
            break
          } else if (cur._needNewLine()) {
            refreshYOffset();
            // 当前是换行的，再上一个就是上一行了，所以停止遍历
            translateX(cur);
            break
          }
        }

        // if (verticalAlign !== 'top') {
        // 取到最大的高度后 对所有的进行对齐
        // TODO: 这里可能还有问题
        cur = this.pre;
        if (!this.next) {
          // 一行中的最后一个
          cur = this;
        }
        while (cur) {
          translateY(cur);
          cur = cur.pre;
          if (!cur) {
            break
          } else if (cur._needNewLine()) {
            // 当前是换行的，再上一个就是上一行了，所以停止遍历
            translateY(cur);
            break
          }
        }
        // }
      } else if (!this.next && !this.pre) {
        cur = this;
        refreshXOffset();
        // 只有一个
        translateX(cur);
      }
    }

  }

  function getContentLayout(element) {
    let width = element.renderStyles.width;
    let height = element.renderStyles.height;
    if (!isExact(width)) width = 0;
    if (!isExact(height)) height = 0;
    return {
      contentWidth: width - element.renderStyles.paddingLeft - element.renderStyles.paddingRight - element.renderStyles.marginLeft - element.renderStyles.marginRight,
      contentHeight: height - element.renderStyles.paddingTop - element.renderStyles.paddingBottom - element.renderStyles.marginTop - element.renderStyles.marginBottom,
      contentX: element.x + element.renderStyles.paddingLeft + element.renderStyles.marginLeft,
      contentY: element.y + element.renderStyles.paddingTop + element.renderStyles.marginTop,
      width,
      height
    }
  }

  class View extends Element {
    _getDefaultStyles() {
      return {
        ...STYLES.DEFAULT_STYLES,
        display: STYLES.DISPLAY.BLOCK
      }
    }

    _completeStyles() {
      super._completeStyles();
      this._completePaddingMargin();
    }

    _completePaddingMargin() {
      if (this.styles.padding) {
        if(isExact(this.styles.padding)){
          this.styles.paddingLeft = this.styles.padding;
          this.styles.paddingBottom = this.styles.padding;
          this.styles.paddingRight = this.styles.padding;
          this.styles.paddingTop = this.styles.padding;
        }else if(Array.isArray(this.styles.padding)){
          // 支持数组[10,20]相当于padding:10px 20px;
          if(this.styles.padding.length === 2){
            this.styles.paddingLeft = this.styles.paddingRight = this.styles.padding[1];
            this.styles.paddingBottom = this.styles.paddingTop =this.styles.padding[0];
          }else if(this.styles.padding.length === 4){
            this.styles.paddingLeft = this.styles.padding[3];
            this.styles.paddingBottom = this.styles.padding[2];
            this.styles.paddingRight = this.styles.padding[1];
            this.styles.paddingTop = this.styles.padding[0];
          }
        }
      }

      if (this.styles.margin) {
        this.styles.marginLeft = this.styles.margin;
        this.styles.marginBottom = this.styles.margin;
        this.styles.marginRight = this.styles.margin;
        this.styles.marginTop = this.styles.margin;
      }else if(Array.isArray(this.styles.margin)){
        // 支持数组[10,20]相当于padding:10px 20px;
        if(this.styles.margin.length === 2){
          this.styles.marginLeft = this.styles.marginRight = this.styles.margin[1];
          this.styles.marginBottom = this.styles.marginTop =this.styles.margin[0];
        }else if(this.styles.margin.length === 4){
          this.styles.marginLeft = this.styles.margin[3];
          this.styles.marginBottom = this.styles.margin[2];
          this.styles.marginRight = this.styles.margin[1];
          this.styles.marginTop = this.styles.margin[0];
        }
      }
    }

    _reflow() {
      super._reflow();
    }

    _repaint() {
      super._repaint();
    }

    _afterPaint() {
      super._afterPaint();
    }

    _drawBackground() {
      const { backgroundColor, contentWidth, contentHeight, paddingLeft, paddingRight, paddingTop, paddingBottom } = this.renderStyles;
      const ctx = this.getCtx();

      this._clip();
      // draw background
      if (backgroundColor) {
        this.getCtx().fillStyle = backgroundColor;
        this.getCtx().fillRect(this.contentX - paddingLeft, this.contentY - paddingTop, contentWidth + paddingLeft + paddingRight, contentHeight + paddingTop + paddingBottom);
      }
    }

    _drawBox() {

      this._drawRadiusBorder();

      // for debug
      if (this.getLayer().options && this.getLayer().options.debug) {
        this.getCtx().strokeStyle = 'green';
        this.getCtx().strokeRect(this.contentX, this.contentY, this.renderStyles.contentWidth, this.renderStyles.contentHeight);
        // ctx.strokeStyle = '#fff'
        // ctx.strokeText(`${parseInt(this.contentX)} ${parseInt(this.contentY)} ${contentWidth} ${contentHeight}`, this.contentX + 100, this.contentY + 10)

        //
      }

    }

    _drawRadiusBorder() {
      if (!(this.renderStyles.borderColor || this.renderStyles.shadowBlur)) return
      const { contentWidth, contentHeight, paddingLeft, paddingTop,
        paddingRight, paddingBottom, shadowBlur, shadowColor, backgroundColor,
        borderLeftWidth, borderRightWidth, borderTopWidth, borderBottomWidth } = this.renderStyles;

      const angle = Math.PI / 2;
      let borderRadius = this._getBorderRadius();


      // 这里是计算画border的位置，起点位置是在线条中间，所以要考虑线条宽度
      let x = this.contentX - this.renderStyles.paddingLeft - borderLeftWidth / 2;
      let y = this.contentY - this.renderStyles.paddingTop - borderTopWidth / 2;
      let w = contentWidth + paddingLeft + paddingRight + (borderLeftWidth + borderRightWidth) / 2;
      let h = contentHeight + paddingTop + paddingBottom + (borderTopWidth + borderBottomWidth) / 2;


      const topBorder = () => {
        // 左上角开始
        this.getCtx().moveTo(x, y + borderRadius);
        borderRadius && this.getCtx().arc(x + borderRadius, y + borderRadius, borderRadius, 2 * angle, 3 * angle);
        this.getCtx().lineTo(x + w - borderRadius, y);
      };
      const rightBorder = () => {
        // 右上角
        // this.getCtx().moveTo(x + w - borderRadius, y)
        borderRadius && this.getCtx().arc(x + w - borderRadius, y + borderRadius, borderRadius, 3 * angle, 4 * angle);
        this.getCtx().lineTo(x + w, y + h - borderRadius);
      };

      const bottomBorder = () => {
        // 右下角
        // this.getCtx().moveTo(x + w, y + h - borderRadius)
        borderRadius && this.getCtx().arc(x + w - borderRadius, y + h - borderRadius, borderRadius, 0, angle);
        this.getCtx().lineTo(x + borderRadius, y + h);
      };

      const leftBorder = () => {
        // 左下角
        borderRadius && this.getCtx().arc(x + borderRadius, y + h - borderRadius, borderRadius, angle, angle * 2);
        this.getCtx().lineTo(x, y + borderRadius);
      };

      this.getCtx().lineCap = this.renderStyles.lineCap;
      this.getCtx().strokeStyle = this.renderStyles.borderColor;

      const stroke = (borderWidth) => {
        // 有样式则绘制出来
        this.getCtx().lineWidth = borderWidth;
        this.getCtx().stroke();
      };
      // 绘制boxshadow
      if (shadowColor && shadowBlur) {
        this._restore(() => {
          this._path(() => {
            topBorder();
            rightBorder();
            bottomBorder();
            leftBorder();
          });
          this.getCtx().shadowBlur = shadowBlur;
          this.getCtx().shadowColor = shadowColor;
          this.getCtx().fillStyle = shadowColor;
          this.getCtx().fill();
        });
      }
      this._restore(() => {
        this._path(() => {

          x = this.contentX - this.renderStyles.paddingLeft - borderLeftWidth / 2;
          y = this.contentY - this.renderStyles.paddingTop - borderTopWidth / 2;
          w = contentWidth + paddingLeft + paddingRight + (borderLeftWidth + borderRightWidth) / 2;
          h = contentHeight + paddingTop + paddingBottom + (borderTopWidth + borderBottomWidth) / 2;
          if (this.renderStyles.borderTopWidth) {
            topBorder();
            stroke(this.renderStyles.borderTopWidth);
          }
          if (this.renderStyles.borderRightWidth) {
            this.getCtx().moveTo(x + w - borderRadius, y);
            rightBorder();
            stroke(this.renderStyles.borderRightWidth);
          }
          if (this.renderStyles.borderBottomWidth) {
            this.getCtx().moveTo(x + w, y + h - borderRadius);
            bottomBorder();
            stroke(this.renderStyles.borderBottomWidth);
          }
          if (this.renderStyles.borderLeftWidth) {
            this.getCtx().moveTo(x + borderRadius, y + h);
            leftBorder();
            stroke(this.renderStyles.borderLeftWidth);
          }
        });
      });






    }

    _clip() {
      if (this.renderStyles.overflow !== 'hidden') return
      const { contentWidth, contentHeight, paddingLeft, paddingTop,
        paddingRight, paddingBottom, shadowBlur, shadowColor, backgroundColor,
        borderLeftWidth, borderRightWidth, borderTopWidth, borderBottomWidth } = this.renderStyles;

      const angle = Math.PI / 2;

      let borderRadius = this._getBorderRadius();

      // 为了把border也切进去
      let x = this.contentX - this.renderStyles.paddingLeft - borderLeftWidth;
      let y = this.contentY - this.renderStyles.paddingTop - borderTopWidth;
      let w = contentWidth + paddingLeft + paddingRight + borderLeftWidth + borderRightWidth;
      let h = contentHeight + paddingTop + paddingBottom + borderTopWidth + borderBottomWidth;

      const topBorder = () => {
        // 左上角开始
        this.getCtx().moveTo(x, y + borderRadius);
        borderRadius && this.getCtx().arc(x + borderRadius, y + borderRadius, borderRadius, 2 * angle, 3 * angle);
        this.getCtx().lineTo(x + w - borderRadius, y);
      };
      const rightBorder = () => {
        // 右上角
        // this.getCtx().moveTo(x + w - borderRadius, y)
        borderRadius && this.getCtx().arc(x + w - borderRadius, y + borderRadius, borderRadius, 3 * angle, 4 * angle);
        this.getCtx().lineTo(x + w, y + h - borderRadius);
      };

      const bottomBorder = () => {
        // 右下角
        // this.getCtx().moveTo(x + w, y + h - borderRadius)
        borderRadius && this.getCtx().arc(x + w - borderRadius, y + h - borderRadius, borderRadius, 0, angle);
        this.getCtx().lineTo(x + borderRadius, y + h);
      };

      const leftBorder = () => {
        // 左下角
        borderRadius && this.getCtx().arc(x + borderRadius, y + h - borderRadius, borderRadius, angle, angle * 2);
        this.getCtx().lineTo(x, y + borderRadius);
      };

      this._path(() => {
        topBorder();
        rightBorder();
        bottomBorder();
        leftBorder();
      });


      this.getCtx().clip();

    }

    _getBorderRadius() {
      const { contentWidth, contentHeight } = this.renderStyles;
      let { borderRadius } = this.renderStyles;
      if (borderRadius * 2 > contentWidth) {
        // 如果大于一半，则角不是90度，统一限制最大为一半
        borderRadius = contentWidth / 2;
      }
      if (borderRadius * 2 > contentHeight) {
        borderRadius = contentHeight / 2;
      }
      if (borderRadius < 0) borderRadius = 0;
      return borderRadius
    }



  }

  class Text extends Element {
    constructor(options, children) {
      super(options, children);
      this._layout = null; // layout用来保存计算的自身高度
      this._lines = [];
      this.children += '';
    }

    _getDefaultStyles() {
      return {
        ...STYLES.DEFAULT_STYLES,
        display: STYLES.DISPLAY.INLINE,
        width: STYLES.WIDTH.AUTO,
        textAlign: 'left',
      }
    }

    _completeStyles() {
      super._completeStyles();
      this._completeFont();
    }

    _completeWidth(){
      super._completeWidth();
      
      if(this.styles.textAlign !== 'left'&& this.parent && !isAuto(this.parent.styles.width)){
        this.styles.width = '100%';
      }
    }

    _completeFont() {
      if (this.styles.fontSize && !this.styles.lineHeight) {
        this.styles.lineHeight = this.styles.fontSize * 1.4;
      } else if (!this.styles.lineHeight) {
        this.styles.lineHeight = 14;
      }
    }

    _initLayout() {
      this._restore(() => {
        this.getCtx().font = this._getFont();
        this._layout = this.getCtx().measureText(this.children);
        // 微信 夸克 有兼容性问题
        // this._layout.fontHeight = this._layout.actualBoundingBoxAscent || this.renderStyles.fontSize
        this._layout.fontHeight = this.renderStyles.fontSize;
        this._layout.height = this.renderStyles.lineHeight;
        this._calcLine();
      });
      super._initLayout();
    }

    _measureLayout() {
      return this._layout
    }

    _drawContent() {
      const { color, contentWidth, lineHeight, textAlign } = this.renderStyles;
      let x = this.contentX;
      this.getCtx().fillStyle = color;
      this.getCtx().textAlign = textAlign;
      this.getCtx().font = this._getFont();
      if (textAlign === STYLES.TEXT_ALIGN.RIGHT) {
        x = this.contentX + contentWidth;
      } else if (textAlign === STYLES.TEXT_ALIGN.CENTER) {
        x = this.contentX + (contentWidth / 2);
      }
      this._lines.forEach((line, index) => {
        this.getCtx().fillText(line, x, (this.contentY + this._layout.fontHeight + ((lineHeight - this._layout.fontHeight) / 2) + lineHeight * index) - 1);
      });
    }

    _getFont() {
      const { fontSize, fontWeight, fontFamily } = this.renderStyles;
      return `${fontWeight} ${fontSize}px ${fontFamily}`
    }

    _calcLine() {
      if (!this.parent || !this.children) return
      const { width: textWidth, height: textHeight } = this._layout;
      const { contentWidth: parentContentWidth } = this.parent.renderStyles;
      const { width: parentWidth } = this.parent.styles;
      // 如果一行宽度够，或者父级宽度是auto
      if ((isExact(parentContentWidth) && parentContentWidth >= textWidth) || parentWidth === STYLES.WIDTH.AUTO) {
        this._lines = [this.children];
      } else {
        this._lines = [];
        let lineIndex = 1;
        let lineText = '';
        let _layout = null;
        for (let i = 0; i < this.children.length; i++) {
          _layout = this.getCtx().measureText(lineText + this.children[i]);
          if (_layout.width > parentContentWidth) {
            if (lineIndex >= this.renderStyles.maxLine) {
              // 最大行数限制 以及maxline省略号实现
              lineText = lineText.substring(0, lineText.length - 2) + '...';
              break
            }
            // 超出了
            this._lines.push(lineText);
            lineText = '';
            lineIndex += 1;

          }

          lineText += this.children[i];
        }
        this._lines.push(lineText);
      }
      // 根据lineheihgt更新height
      this._layout.height = this._lines.length * this.renderStyles.lineHeight;
    }
  }

  class $Image extends View {

    init() {
      super.init();
      this._imageInfo = {
        width: 0,
        height: 0,
        sx:0,
        sy:0,
        swidth:0,
        sheight:0,
        dx:0,
        dy:0,
        dwidth:0,
        dheight:0
      };
      this._image = null;
      this._loadImage();
    }

    _loadImage() {
      return new Promise((resolve, reject) => {
        loadImage(this.options.attrs.src, this.getLayer().getCanvas())
          .then(({ info, image }) => {
            this._imageInfo = info;
            this._image = image;
            resolve();

            this._layoutImage();

            // 重新布局绘制
            this.getLayer().reflow();
            this.getLayer().repaint();
          });
      })
    }

    _drawContent() {
      if (!this._image) return
      const { contentWidth, contentHeight } = this.renderStyles;
      const {mode} = this.options.attrs;
      const {sx,sy,swidth,sheight,dx,dy,dwidth,dheight,width:imageW,height:imageH} = this._imageInfo;
      if(mode === 'aspectFill'){
        this.getCtx().drawImage(this._image,sx,sy,swidth,sheight, this.contentX, this.contentY, contentWidth, contentHeight);
      }else if(mode === 'aspectFit'){
        this.getCtx().drawImage(this._image,0,0,imageW,imageH,dx,dy,dwidth,dheight);
      }else {
        this.getCtx().drawImage(this._image, this.contentX, this.contentY, contentWidth, contentHeight);
      }
    }

    // 计算图片布局
    _layoutImage() {
      const { contentWidth, contentHeight } = this.renderStyles;
      const {mode} = this.options.attrs;
      const { width, height } = this.styles;
      const {width:imageW,height:imageH} = this._imageInfo;
      // 根据用户设置判断图片宽高，目前支持widthfix、heightfix、平铺
      let w = contentWidth;
      let h = contentHeight;
      if (!isAuto(width) && isAuto(height)) {
        // width fix
        w = contentWidth;
        h = getHeightByWidth(w, imageW, imageH);
      } else if (!isAuto(height) && isAuto(width)) {
        // height fix
        h = contentHeight;
        w = getWidthByHeight(h, imageW, imageH);
      } else if (isAuto(width) && isAuto(height)) {
        // auto
        w = imageW;
        h = imageH;
      }else if(mode === 'aspectFill'){
        // 填充
        if((w/h) > (imageW/imageH)){
          this._imageInfo.swidth = imageW;
          this._imageInfo.sheight = getHeightByWidth(imageW,w,h);
          this._imageInfo.sx = 0;
          this._imageInfo.sy = (imageH - this._imageInfo.sheight)/2;
        }else {
          this._imageInfo.sheight = imageH;
          this._imageInfo.swidth = getWidthByHeight(imageH,contentWidth,contentHeight);
          this._imageInfo.sy = 0;
          this._imageInfo.sx = (imageW - this._imageInfo.swidth)/2;
        }
      }else if(mode === 'aspectFit'){
        if((w/h) > (imageW/imageH)){
          this._imageInfo.dwidth = getWidthByHeight(contentHeight,imageW,imageH);
          this._imageInfo.dheight = contentHeight;
          this._imageInfo.dy = this.contentY;
          this._imageInfo.dx = (contentWidth - this._imageInfo.dwidth)/2 + this.contentX;
        }else {
          this._imageInfo.dheight = getHeightByWidth(contentWidth,imageW,imageH);
          this._imageInfo.dwidth = contentWidth;
          this._imageInfo.dx = this.contentX;
          this._imageInfo.dy = (contentHeight - this._imageInfo.dheight)/2 + this.contentY;
        }
      }else {
        w = contentWidth;
        h = contentHeight;
      }
      this.renderStyles.contentWidth = w;
      this.renderStyles.contentHeight = h;
      this._calcLayoutWithContent();
    }


  }

  // canvas可能为空，小程序下必传
  function loadImage(src, canvas) {

    return new Promise((resolve, reject) => {
      let image = null;

      if (isWX()) {
        image = canvas.createImage();
      } else {
        image = new Image();
      }

      image.src = src;
      image.onload = function (e) {
        resolve({
          image,
          info: {
            width: e.target.width,
            height: e.target.height
          }
        });
      };

    })
  }

  function getWidthByHeight(height, originWidth, originHeight) {
    return height / originHeight * originWidth
  }

  function getHeightByWidth(width, originWidth, originHeight) {
    return width / originWidth * originHeight
  }

  class EventManager {

    constructor({ simulateClick = true }) {
      this.clickList = [];
      this.touchstartList = [];
      this.touchmoveList = [];
      this.touchendList = [];
      this.touchStartEvent = null;
      this.simulateClick = simulateClick; // 是否模拟移动端点击事件
    }

    clear() {
      this.clickList = [];
      this.touchstartList = [];
      this.touchmoveList = [];
      this.touchendList = [];
    }

    click(x, y) {
      let event = new Event({ x, y, type: 'click' });
      this._emit(event);
    }

    touchstart(x, y) {
      let event = new Event({ x, y, type: 'touchstart' });
      this.touchStartEvent = event;
      this._emit(event);
    }

    touchmove(x, y) {
      let event = new Event({ x, y, type: 'touchmove' });
      this._emit(event);
    }

    touchend(x, y) {
      let event = new Event({ x, y, type: 'touchend' });
      this._emit(event);
      this.checkClick(event);
    }

    _emit(e) {
      let callbackList = [];
      switch (e.type) {
        case 'click': callbackList = this.clickList; break
        case 'touchstart': callbackList = this.touchstartList; break
        case 'touchmove': callbackList = this.touchmoveList; break
        case 'touchend': callbackList = this.touchendList; break
      }
      for (let i = 0; i < callbackList.length; i++) {
        if (this.isPointInElement(e.x, e.y, callbackList[i].element)) {
          if (!e.currentTarget) e.currentTarget = callbackList[i].element;
          callbackList[i].callback(e);
          if (e.cancelBubble) break
        }
      }
    }

    isPointInElement(x, y, element) {
      const { width, height } = element.renderStyles;
      let _x = x; // 根据scroll-view做转换
      let _y = y;
      let cur = element.parent;
      while (cur) {
        if (cur.type === 'scroll-view') {
          if (cur.styles.direction === 'x') {
            _x -= cur.currentScroll;
          } else {
            _y -= cur.currentScroll;
          }
        }
        cur = cur.parent;
      }
      if (_x >= element.x && _y >= element.y && (_x <= element.x + width) && (_y <= element.y + height)) {
        return true
      }
      return false
    }

    createEvent(x, y, type) {

    }

    onClick(callback, element) {
      // 为啥要unshift呢，因为元素是从父级,往子集初始化的
      this.clickList.unshift({ callback, element });
    }

    onTouchStart(callback, element) {
      this.touchstartList.unshift({ callback, element });
    }

    onTouchMove(callback, element) {
      this.touchmoveList.unshift({ callback, element });
    }

    onTouchEnd(callback, element) {
      this.touchendList.unshift({ callback, element });
    }

    // 这里利用touchstart和touchend实现了移动端click事件
    checkClick(event) {
      if (this.touchStartEvent && this.simulateClick) {
        // 判断两点距离
        let { x: startx, y: starty } = this.touchStartEvent;
        let { x: endx, y: endy } = event;
        let distance = ((endy * endy + endx * endx) - (starty * starty + startx * startx));
        if (distance < 10 && distance > -10) {
          this.click(endx, endy);
        }
      }
    }
  }

  class Event {
    constructor({ x, y, type }) {
      this.x = x;
      this.y = y;
      this.type = type;
      this.cancelBubble = false;
      this.currentTarget = null; // 第一个element
    }

    // 阻止冒泡
    stopPropagation() {
      this.cancelBubble = true;
    }
  }

  class Layer {
    constructor(ctx, options) {
      this.ctx = ctx;
      this.node = null;
      this.nodeList = [];
      this.renderList = [];
      this.options = options;
      this.eventManager = new EventManager(options);
    }

    update(ctx,options){
      this.ctx = ctx;
      this.options = options;
      this.node.container = this.options;
    }

    mountNode(node) {
      this.node = node;
      this.node.layer = this;
      this.node.container = this.options;
      // 事件也清空一下，重新挂载
      this.eventManager.clear();
      this.initRender();
    }

    initRender() {
      const nodes = this.nodeList = this.node.tree2List();

      this.initPaintList();

      nodes.forEach(item => {
        item.init();
      });
      

      this.flow();

      // inline-block等还需要再重新排一次，待优化
      // this.reflow()

      this.repaint();

    }

    flow(){
      this.nodeList.forEach(item => {
        item._initLayout();
      });
      this.reflow();
    }

    initPaintList() {
      // 这里实现index
      this.renderList = this.nodeList;
    }

    reflow() {
      this.nodeList.forEach(item => {
        item._reflow();
      });
    }

    /**
     * 可以给定element，则只会重绘element所在的区域
     * @param {Element} element
     */
    repaint(element = this.node) {
      // let width = element.renderStyles.width
      // let height = element.renderStyles.height
      // let x = element.x
      // let y = element.y
      // this.ctx.clearRect(x, y, width, height)
      // walk(element, (item) => {
      //   item._repaint()
      //   item._afterPaint()
      // })

      this.ctx.clearRect(this.node.x, this.node.y, this.node.renderStyles.width, this.node.renderStyles.height);
      this.renderList.forEach(element => {
        element._repaint();
        element._afterPaint();
      });
      // 兼容小程序
      this.ctx.draw && this.ctx.draw();
    }

    // 小程序需要
    getCanvas() {
      return this.options && this.options.canvas
    }

  }

  class ScrollView extends View {

    constructor(options, children) {
      super(options, children);
      // 外面包裹一层容器，内层的滚动
      options.styles.overflow = 'hidden';
      this.type = 'scroll-view';
      this._scrollView = new View(options, [this]);
      return this._scrollView
    }

    _getDefaultStyles() {
      return {
        ...STYLES.DEFAULT_STYLES,
        direction: 'y',
      }
    }

    init() {
      super.init();
      this.addEventListener();

      const { height, width, direction } = this.styles;
      if (direction === 'y') {
        if (!isAuto(height)) {
          this.styles.height = 'auto';
          this.renderStyles.height = 'auto';
        } else {
          // 必须设置
          console.error('scroll-view 必须设置明确的高度');
        }
      } else if (direction === 'x') {
        if (!isAuto(width)) {
          this.styles.width = 'auto';
          this.renderStyles.width = 'auto';
        } else {
          // 必须设置
          console.error('scroll-view 必须设置明确的宽度');
        }
      }
    }

    addEventListener() {
      // 监听滚动
      this.currentScroll = 0;
      let direction = this.styles.direction;
      let start = 0;
      let lastStart = 0;
      let startMove = false;
      let offset = 0;
      let speed = 0;
      let glideInterval = null;
      let resistance = 1;
      this.getLayer().eventManager.onTouchStart((e) => {
        e.stopPropagation();
        start = e[direction];
        lastStart = start;
        startMove = true;
        clearInterval(glideInterval);
      }, this);
      this.getLayer().eventManager.onTouchMove((e) => {
        if (startMove) {
          e.stopPropagation();
          offset = (e[direction] - start);
          if (this.scrollBy(offset)) {
            lastStart = start;
            start = e[direction];
          }
        }
      }, this);
      this.getLayer().eventManager.onTouchEnd((e) => {
        if (startMove) {
          startMove = false;
          speed = (e[direction] - lastStart) * 2;
          resistance = -speed * 0.02;
          clearInterval(glideInterval);
          glideInterval = setInterval(() => {
            if (!this.scrollBy(speed)) {
              clearInterval(glideInterval);
            }
            speed += resistance;
            if (speed * speed <= 0.05) {
              speed = 0;
              clearInterval(glideInterval);
            }
          }, 18);
        }
      }, this);
    }

    _repaint() {
      // 滚动实现 目前是计算一次重新绘制一次，有需要再优化
      const { direction } = this.renderStyles;
      if (direction === 'y') {
        this.getCtx().translate(0, this.currentScroll);
      } else {
        this.getCtx().translate(this.currentScroll, 0);
      }
      super._repaint();
    }

    calcScrollBound(offset) {
      const { width: offsetWidth, height: offsetHeight } = this._scrollView.renderStyles;
      const { width: scrollWidth, height: scrollHeight, direction } = this.renderStyles;
      if (direction === 'y') {
        if ((offsetHeight - this.currentScroll - offset) > scrollHeight) {
          return false
        } else if (this.currentScroll + offset > 0) {
          return false
        }
      } else {
        if ((offsetWidth - this.currentScroll - offset) > scrollWidth) {
          return false
        } else if (this.currentScroll + offset > 0) {
          return false
        }
      }

      return true
    }

    scrollBy(offset) {
      if (this.calcScrollBound(offset)) {
        this.currentScroll += offset;
        this.getLayer().repaint();
        // this.getLayer().repaint(this._scrollView)
        return true
      } else {
        return false
      }
    }

    scrollTo(pos) {

    }

  }

  /**
   * 生成一个element tree
   * @param {String} name
   * @param {Function} options
   */

  const elementFactory = {};
  //
  registerComponent('view', (options, children) => new View(options, children));
  registerComponent('text', (options, children) => new Text(options, children));
  registerComponent('image', (options, children) => new $Image(options, children));
  registerComponent('scroll-view', (options, children) => new ScrollView(options, children));
  registerComponent('scrollview', (options, children) => new ScrollView(options, children));

  function createElement(model) {
    // 生成树
    function c(name, options = {}, children = []) {
      // if (arguments.length < 3) {
      //   throw Error(`Element [${name}]: need 3 argument but get 2`)
      // }
      let _element = null;
      let _children = children;
      if (elementFactory[name]) {
        // if (typeof children === 'string' && name !== 'text') {
        //   // 支持text简写
        //   _children = new Text({}, children)
        // } else if (!Array.isArray(children)) {
        //   throw Error(`Element [${name}]:Children must be type of Array!`)
        // }
        _element = elementFactory[name](options, _children, c);
      } else {
        throw Error(`Unknown tag name [${name}] !`)
      }
      return _element
    }
    const _model = model(c);
    // 挂载children
    return _model
  }

  function createLayer(ctx, options) {
    return new Layer(ctx, options)
  }

  // 注册全局组件
  function registerComponent(name, factory) {
    if (elementFactory[name]) {
      throw Error(`Already exist tag name [${name}] !`)
    }
    elementFactory[name] = factory;
  }

  const ef = {
    createLayer,
    createElement,
    component: registerComponent,
    View,
    Text,
    Image: $Image,
    Layer,
    ScrollView
  };

  return ef;

})));
